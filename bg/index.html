<!DOCTYPE html>
<html lang='bg'>

<head>
  <title>C# Turbo Курс</title>
  <meta charset='utf-8'>
  <meta name="viewport"  content="width=device-width, initial-scale=1.0">
  <link rel='preload'    href='../font/lato.woff2' as='font' type='font/woff2' crossorigin>
  <link rel='preload'    href='../font/mono.woff2' as='font' type='font/woff2' crossorigin>
  <script>console.clear();</script><!-- cleanup console on startup -->
  <link rel='stylesheet' href='../css/font.css'>
  <link rel='stylesheet' href='../css/style.css'>
  <link rel='stylesheet' href='../css/menu.css'>
</head>                        

<body id='top' onload='initscroll();'>
  
  <div id='menu' class='menu'>
    <div class='progress-bar'>
      <div id='scroll' class='progress-bar-fill pbzero'> </div>
    </div>
    <nav data-scroll-header class='menunav no-print'> <a id='menu-toggle' onclick='MainMenu();'>&#x2261;</a>
      <!-- Menu &#x2261; &#x00D7; ≡ ˟ -->
      <ul data-gumshoe class='menuitems' id='toggled'>
        <li><a data-scroll href='#I'    onclick='closeMenu()'>I</a></li>
        <li><a data-scroll href='#II'   onclick='closeMenu()'>II</a></li>
        <li><a data-scroll href='#III'  onclick='closeMenu()'>III</a></li>
        <li><a data-scroll href='#IV'   onclick='closeMenu()'>IV</a></li>
        <li><a data-scroll href='#V'    onclick='closeMenu()'>V</a></li>
        <li><a data-scroll href='#VI'   onclick='closeMenu()'>VI</a></li>
        <li><a data-scroll href='#VII'  onclick='closeMenu()'>VII</a></li>
        <li><a data-scroll href='#VIII' onclick='closeMenu()'>VIII</a></li>
        <li><a data-scroll href='#IX'   onclick='closeMenu()'>IX</a></li>
        <li><a data-scroll href='#X'    onclick='closeMenu()'>X</a></li>
      </ul>
    </nav>
  </div>
  
  <div id='content'>
    
    <h1>C# Turbo Курс</h1>
    
    <hr>
    
    <img src='../img/image013.jpg' class='img no-print' alt='C# Turbo Course'>
    
    <hr>
    
    <h2 id='I'>I. Въведение в курса</h2>
    
    <p><b>.NET поддържа различни видове приложения:</b></p>
    <p><b>Desktop</b> приложения: Това са традиционни приложения, които
      работят на базирани на Windows платформи за настолни компютри. Те предоставят
      богат потребителски интерфейс и могат да бъдат изградени с помощта на технологии
      като Windows Forms (WinForms) или Windows Presentation Foundation (WPF).</p>
    <p>Приложения за <b>macOS</b>: .NET поддържа разработването на приложения за macOS
      с помощта на технологии като Xamarin.Mac и .NET MAUI (Мултиплатформен потребителски
      интерфейс на приложения). Те позволяват изграждане на родни macOS приложения
      с помощта на C# и .NET.</p>
    <p><b>Linux</b> приложения: .NET Core и .NET 5+ поддържат разработването на приложения
      за Linux дистрибуции като Ubuntu. Можете да създавате конзолни приложения,
      уеб приложения или дори десктоп приложения, насочени към платформата Linux.</p>
    <p><b>WEB</b> приложения: .NET позволява разработването на уеб приложения, използващи
      технологии като ASP.NET, ASP.NET Core и Blazor. Тези приложения работят на
      уеб сървъри и могат да бъдат достъпни чрез уеб браузъри, осигурявайки динамично
      и интерактивно преживяване.</p>
    
    <p><b>Network Stack: Backend/Middleware/Frontend</b></p>
    
    <object class='obsvg' title='Network Stack' data='../img/image015.svg' type='image/svg+xml'></object>
    
    <p><b>WEB стекът</b> е много сложен наистина, но ако го погледнете верикално, може да изглежда по следния начин:</p>
        
    <object class='obsvg' title='Vertical Stack' aria-hidden="true" data='../img/image017.svg' type='image/svg+xml'></object>    
    
    <p><b>iOS</b>: Xamarin също позволява разработката на приложения за iOS с помощта
      на C# и .NET. Позволява споделяне на код между iOS, Android и други платформи.</p>
    <p><b>Android</b>: С Xamarin можете да създавате приложения за Android, като използвате
      C# и .NET. Xamarin позволява споделяне на код между Android, iOS и други платформи.</p>
    <p><b>Windows
      Phone</b>: Разработката на Windows Phone се поддържа чрез използване на технологии
      като Windows Phone Silverlight и Universal Windows Platform (UWP).</p>
    <p><b>Други</b> платформи: .NET също има поддръжка за други платформи, включително
      интелигентни телевизори, IoT устройства, конзоли за игри и други чрез рамки
      като .NET Core, Xamarin и Mono.</p>
    
    <p><b>Net приложения и инструменти</b></p>
    <p><b>GitHub
      Codespaces</b> е облачно базирана среда за разработка, предоставена от GitHub.
      Той позволява на разработчиците да създават и управляват напълно конфигурирани
      среди за разработка в своя браузър. Codespaces предоставя безпроблемно и съвместно
      изживяване при кодиране, което позволява на разработчиците да пишат, изграждат,
      тестват и отстраняват грешки директно от своя уеб браузър без необходимост
      от сложни локални настройки. Той се интегрира тясно с хранилищата на GitHub,
      което улеснява клонирането, редактирането и предаването на код директно в средата
      на Codespaces.</p>
    <p>GitHub Codespaces ви позволява да отваряте GitHub проекти директно в среда за
      онлайн разработка. Той предоставя облак базирана, достъпна от браузър среда
      за разработка с предварително конфигурирани инструменти и готови библиотеки.
      Ако имате проект в GitHub, в Codespaces можете лесно да си сътрудничите, да
      разработвате и тествате код, без да е необходимо да настройвате локална среда
      за разработка или да инсталирате софтуер на вашия локален компютър. Codespaces
      поддържа различни програмни езици и рамки, което позволява на разработчиците
      да работят върху различни типове проекти, включително десктоп, уеб, мобилни
      и мултиплатформени приложения. Той предлага интегрирана разработка ма софтуер
      с функции като редактиране на код, отстраняване на грешки, терминален достъп
      и инструменти за сътрудничество, което го прави удобно средство за отделни
      лица или екипи и подпомага тяхната работа по проекти от всяко място.</p>
    
    <p><b>Common Language Runtime (CLR)</b> </p>
    <p>Common Language Runtime (CLR) е средата за изпълнение на .NET приложения. Той
      предоставя основни услуги като управление на паметта, обработка на изключения
      и рециклиране на паметта, заета от обекти /garbage collector/. CLR също така
      компилира и изпълнява .NET байт код, известен като Common Intermediate Language
      (CIL), в машинен код по време на изпълнение за по ефикасно изпълнение. Той
      предлага управлявана среда за изпълнение, която гарантира безопасност на използваните
      типове данни, сигурност и езикова оперативна съвместимост, позволявайки на
      различни .NET езици да работят безпроблемно заедно. Освен това CLR предоставя
      функции като компилация в реално време /JIT - Just In Time/ , автоматично управление
      на паметта и стабилно обработване на грешки, което допринася за надеждността
      и производителността на .NET приложенията.</p>
    
    <p><b>NuGet</b></p>
    <p>Пакетите NuGet са модулни единици код, които могат лесно да се споделят и използват
      повторно в различни проекти. Те съдържат библиотеки, рамки /frameworks/, инструменти
      и други, които подобряват и улесняват процеса на разработка. С пакетите NuGet
      разработчиците могат лесно да включат съществуваща функционалност в своите
      приложения, спестявайки време и усилия. Тези пакети се управляват чрез мениджъра
      на пакети NuGet, което опростява управлението на зависимостите на проектите
      от дадени пакети и контрола на версиите на библиотеките.</p>
    
    <p><b>CLI - Command Line Interface</b></p>
    <p>Когато създавате приложение с помощта на .NET CLI, започвате с отваряне на конзолата
      или терминала, който служи като интерфейс на командния ред. Оттам можете да
      използвате командата <b>dotnet</b>, за да създадете нов проект, да напишете
      код, да компилирате приложението и да го стартирате. .NET CLI осигурява рационализиран
      работен процес за изграждане и управление на .NET приложения. С помощта на
      GitHub Codespaces се предоставя среда за разработка, която ви позволява да
      се съсредоточите върху писането на код, докато платформата се грижи за основната
      инфраструктура и процесите на изграждане.</p>
    
    <p><b>Hold my beer</b></p>
    <p>Създаване на приложението <b>Hold my beer</b>. Инструментите на dotnet предлагат
      лесен начин за създаване на приложение от вида "Hello World!". Просто трябва
      се въведе следната команда, за да бъде създадено конзолно приложение:</p>
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank $ <b>mkdir holdmybeer</b>
@404joe ➜ /workspaces/codespaces-blank $ <b>cd holdmybeer</b>
@404joe ➜ /workspaces/codespaces-blank/holdmybeer $ <b>dotnet new console</b>
</pre>
    <p>Тази команда създава нов проект - файла <b>holdmybeer.csproj</b> в директорията
      <b>holdmybeer</b>и добавя файл с изходния код на име <b>Program.cs</b>. Командата
      <b>dotnet new</b> също така включва функционалността за възстановяване на <b>dotnet</b>,
      като автоматично на сървъра на Github Codespaces се изтеглят и инсталират всички
      необходими <b>NuGet</b> пакети. За се види списък със зависимости от библиотеки
      и техните версии, използвани от приложението, може да се провери файла project.assets.json
      в поддиректорията obj. Ако не се използва опцията <b>-–output</b> (или <b>-o</b> за съкратено
      изписване на име на директория), файловете се генерират в текущата директория.</p>
    <p><b>Създаване
      на Web Application</b></p>
    <p>Подобно на създаването на конзолно приложение, .NET CLI. може да се използва,
      за създаване на уеб приложение. Ако се въведе <b>dotnet new</b>, излиза списък с наличните
      шаблони. Командата <b>dotnet new webapp</b> създава ново уеб приложение с използването на 
      технологиите ASP.NET Core и Razor Pages. Създаденият по този начин проектен файл включва 
      Microsoft.NET.Sdk.Web SDK. Този SDK (Software Development Kit) съдържа инструменти и разширения,
      които са необходими за създаване на уеб приложения и услуги:</p>
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank/holdmybeer $ <b>cd ..</b>
@404joe ➜ /workspaces/codespaces-blank $ <b>mkdir webapp</b>
@404joe ➜ /workspaces/codespaces-blank $ <b>cd webapp</b>
@404joe ➜ /workspaces/codespaces-blank/webapp $ <b>dotnet new webapp</b>
@404joe ➜ /workspaces/codespaces-blank/webapp $ <b>dotnet run</b>

Резултат: Now listening on: http://localhost:5234
</pre>
    <p>Автоматично се стартира <b>Nginx</b> сървъра на ASP.NET Core и започва да слуша на
      порт 5234 /или друг 5xxx порт/. Може да се отвори браузър за достъп до страниците
      /ако кликнете линка localhost по-горе/, които този сървър връща, както е показано
      на следната фигура</p>
    <p><img src='../img/image001.jpg' class='img' alt='Web App'></p>
    
    <p><b>Self-Contained Deployments</b></p>
    <p>Самостоятелните внедрявания се отнасят до модел на внедряване /доставка на изпълнимия
      файл до потребителя/, при който приложението и всичките му зависимости са обединени
      в един пакет. Този пакет включва .NET среда за изпълнение, библиотеки и други
      ресурси, необходими за изпълнение на приложението на системата на крайния потребител.
      Самостоятелните внедрявания са специфични за платформата и независими от инсталирания
      .NET на целевата машина. Този подход гарантира, че приложението може да работи
      на системи дори без необходимост от предварително инсталирана .NET платформа,
      което улеснява разпространението и внедряването на .NET приложения за различни
      операционни системи.</p>
<pre class='pre'>
$ dotnet publish -c Release -r win10-x64
$ dotnet publish -c Release -r osx.10.11-x64
$ dotnet publish -c Release -r ubuntu-x64
</pre>
    <p>След изпълнението на тези команди, необходимите файлове за публикуване могат
      да бъдат намерени в директориите Release/[win10-x64|osx.10.11-x64|ubuntu-x64]/publish.
      </p>
    <p><b>Ключови думи в езика C#</b></p>
    <p>Ключовите думи са запазени думи в езика, и не могат да бъдат използвани за друго,
      освен като ключови думи; тоест имената на класовете, обектите, методите, променливите
      трябва да са различни. Това са думите от следния спсък:</p>
    <p><b>abstract as base bool break byte case catch char checked class const continue
      decimal default delegate do double else enum event explicit extern false finally
      fixed float for foreach goto if implicit in int interface internal is lock
      long namespace new null object operator out override params private protected
      public readonly ref return sbyte sealed short sizeof stackalloc static string
      struct switch this throw true try typeof uint ulong unchecked unsafe ushort
      using virtual void volatile while</b></p>
    <hr>
    <p><b>Задачи</b></p>
    <p>1. Направете си акаунт в gbithub:
      <a href='https://github.com/signup' target='_blank' class='lnk'>https://github.com/signup</a>
    </p>
    <p>2. Влезте в акаунта си, и създайте ново Repository /сорс-код на проект/
      <a href='https://github.com/new' target='_blank' class='lnk'>https://github.com/new</a>,
      именовайте го csharp, или както желаете. Качете празен файл file.txt, създаден с Notepad на вашия Desktop.
    </p>
    <p>3. Отидете на Codespaces :
      <a href='https://github.com/codespaces' target='_blank' class='lnk'>https://github.com/codespaces</a>
    </p>
    <!--p>3. Изберете Templates ➜ Blank ➜ New</p-->
    <p>4. Изберете Repository ➜ вашето Repository, от 1а, Дайте Create</p>
    <p>5. Върнете се в Codespaces /
      <a href='https://github.com/codespaces' target='_blank' class='lnk'>https://github.com/codespaces</a>
    </p>
    <p>6. Отидете в Owned by - вашето потребителско име - под него е новия шаблон /<b>template</b>/,
      изберете ... в дясно от него, дайте <b>Rename</b>, и го преименувайте на <b>csharp</b></p>
    <p>7. Щракнете въху <b>csharp</b> - ляв бутон.</p>
    <p>8. В ляво изберете квадратчето Extensions, в търсачката Extension Marketplace
      въведете C#, и изберете <b>C# for Visual Studio Code (powered by OmniSharp)</b>.</p>
    <p>9. Натиснете бутона <b>[Install]</b></p>
    <p>10. От менюто <b>&#x2261;</b> горе ляво, изберете <b>Terminal/New terminal</b></p>
    <p><img src='../img/image002.jpg' class='img' alt='Main Menu'></p>
    <p>Забележка: В терминала можете да пишете следните команди /както и много други/:</p>

<pre class='pre'>
<b>mkdir  hold</b> ➜ създава дирекрория <b>hold</b>; 
<b>ls -la</b> ➜ показва списък с файловете и директориите в текущата директория
<b>cd hold</b> ➜ влиза в директория <b>hold</b>
<b>cd ..</b> ➜ излиза от текущата директория, във външната
<b>rm -rf hold</b> ➜  изтрива директория <b>hold</b> и директориите и файловете в нея; 
<b>rm</b> - remove, <b>+ r</b>-recursive <b>+ f</b>-files ➜ <b>rm -rf</b> 
</pre>
    <p>Изпълнете:</p>
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank $ <b>mkdir hold</b>
@404joe ➜ /workspaces/codespaces-blank $ <b>ls -la</b>
</pre>
    <p>Резултат:</p>
<pre class='pre'>
total 12
drwxrwxrwx+ 3 codespace root      4096 May 12 19:13 .
drwxr-xrwx+ 5 codespace root      4096 May 12 18:59 ..
drwxrwxrwx+ 2 codespace codespace 4096 May 12 19:13 <b>hold</b>
@404joe ➜/workspaces/codespaces-blank $ 
</pre>
    <p>11. Влезте в hold /<b>cd hold</b>/ </p>
<pre class='pre'>
@404joe ➜/workspaces/codespaces-blank $ <b>cd hold</b>
@404joe ➜/workspaces/codespaces-blank/hold $ <b>ls -la</b>
</pre>
    <p>Резултат:</p>
<pre class='pre'>
total 8
drwxrwxrwx+ 2 codespace codespace 4096 May 14 14:58 .
drwxrwxrwx+ 7 codespace root      4096 May 14 14:58 ..
@404joe  ➜/workspaces/codespaces-blank/hold $ 
</pre>
    <p>12. Във <b>hold</b> изпълнете <b>dotnet new console:</b></p>
<pre class='pre'>
@404joe  ➜/workspaces/codespaces-blank/hold $ dotnet new console
</pre>

    <p>Резултат:</p>
<pre class='pre'>
The template "Console App" was created successfully.
Processing post-creation actions...
Restoring /workspaces/codespaces-blank/hold/hold.csproj:
  Determining projects to restore...
  Restored /workspaces/codespaces-blank/hold/hold.csproj (in 117 ms).
Restore succeeded.
@404joe  ➜/workspaces/codespaces-blank/hold $
</pre>
    <p>Създават се файловете <b>Program.cs</b> - файла с прогртамата, <b>hold.csproj</b>
    - файла на проекта, директория <b>obj</b></p>

<pre class='pre'>
@404joe ➜/workspaces/codespaces-blank/hold $ <b>ls -la</b>
</pre>

    <p>Резултат:</p>
<pre class='pre'>
total 20
drwxrwxrwx+ 3 codespace codespace 4096 May 14 15:00 .
drwxrwxrwx+ 7 codespace root      4096 May 14 14:58 ..
-rw-rw-rw-  1 codespace codespace  105 May 14 15:00 Program.cs
-rw-rw-rw-  1 codespace codespace  249 May 14 15:00 hold.csproj
drwxrwxrwx+ 2 codespace codespace 4096 May 14 15:00 obj
@404joe  ➜/workspaces/codespaces-blank/hold $ 
</pre>
    <p><b>13. горе в ляво, се появяват въпросните файлове:</b></p>
    <p><img src='../img/image003.jpg' class='img' alt='File Tree'></p>
    <p>14. обратно в терминала компилирате проекта:</p>

<pre class='pre'>
@404joe ➜/workspaces/codespaces-blank/hold $ <b>dotnet build</b>
</pre>

    <p>Резултат:</p>

<pre class='pre'>
MSBuild version 17.5.1+f6fdcf537 for .NET
  Determining projects to restore...
  All projects are up-to-date for restore.
   hold ➜ /workspaces/codespaces-blank/hold/bin/Debug/net7.0/hold.dll
Build succeeded.
    0 Warning(s)
    0 Error(s)
Time Elapsed 00:00:05.21
@404joe ➜/workspaces/codespaces-blank/hold $ 
</pre>
    <p>15. <b>dotnet run</b> за да го стартирате</p>

<pre class='pre'>
@404joe ➜/workspaces/codespaces-blank/hold $ <b>dotnet run</b>

<b>Hello, World!<span class='grn'>&lt;- Резултат от изпълнението на програмата</span></b>
@404joe ➜ /workspaces/codespaces-blank/hold $ 
</pre>

    <p>16. Може да заместите съдържанието на файла Program.cs със следното:</p>

<pre class='pre'>
using System;

namespace MyApplication 
{

    class Program  
    {
        static void Main(string[] args) 
        {
            Console.WriteLine("Hold my beer!");
        }
    }
    
}     

// Резултат:
// Hold my beer!   
</pre>        
        
        
    <p>17. <b>dotnet run </b>➜ в терминала, за да прекомпилирате, и стартирате с една команда.</p>
    <p><b>dotnet build</b> - създава hold.dll /dyamic link library/, за да създатете .exe /executable/, използвайте: </p>
<pre class='pre'>
<b>dotnet publish -c Release -r win-x64</b>
</pre>
    <p>Резултата е в <b>/workspaces/codespaces-blank/hold/bin/net7.0/win-x64/publish/hold.exe</b></p>
    <p>в лявата част на екрана:</p>
    <p><img src='../img/image004.jpg' class='img narrow' alt='Exe Path'></p>
    <p>Този изпълним .exe файл може да бъде изтеглен на локалния ви компютър и изпълнен
      локално /изтеглете чрез десн бутон въху директорията <b>win10-x64</b> на hold.exe файла ➜ download/.</p>
    <p><b>Други полезни команди:</b></p>
<pre class='pre'>
<b>pwd</b> ➜ показва пътя до текущата директория
<b>cat Program.cs</b> ➜ Отпечатва съдържанието на <b>Program.cs</b> в терминала;
<b>cat Pro[+tab&#x21C6;] ➜ cat Program.cs</b> ➜ автоматично довършва името на файла който започва с <b>Pro</b>
<b>[ctrl] + l</b> ➜ за да се почисти терминала
<b>[ctrl] + c</b> ➜ за да се прекъсне процес
<b>↑</b> или <b>↓</b> ➜ предишни команди
<b>[ctrl]</b> + <b>[space]</b> ➜ Автоматично довършване на командата в Редактора /Погледнете следващото изображение/
</pre>

    <p><img src='../img/image018.jpg' class='img' alt='Autocomplete Intellisense'></p>

    <p><b><span class='red'>!!!</span></b> Имената на файловете и директориите са чуствителни
      към малка и голяма буква, файла <b><span class='red'>P</span>rogram.cs</b>
      е различен от файла <b><span class='red'>p</span>rogram.cs</b> <b><span class='red'>!!!</span></b></p>
    
    <p>@404joe $ <b>grep -rnw <span class='red'>.</span> -e '<span class='blu'>Main</span>'
      --include \*<span class='grn'>.cs</span>   </b>➜<b> </b> За да търсите реда, съдържащ символния 
      низ <b><span class='blu'>Main</span></b>
      във всички поддиректории на текущата директория ( <span class='red'>.</span> ), във всички файлове с
      разширението <b><span class='grn'>.cs</span></b><span class='grn'></span> показва реда
      (<b><span class='lil'>7</span></b>), ако търсеният низ бъде намерен: </p>  

<pre class='pre'>
@404joe➜/workspaces/codespaces-blank/hold $ <b>grep -rnw . -e 'Main' --include \*.cs</b>
</pre>


    
    <p>Резултат:</p>
<pre class='pre'>
./Program.cs:<b><span class='lil'>7</span></b>:        static void Main(string[] args)
@404joe➜/workspaces/codespaces-blank/hold $
</pre>

    <hr>
    
    <p>18. Примерите към курса може да разгледате на този <a href="https://github.com/404joe/csharp/tree/master/_examples" target='_blank' class='lnk'>линк</a>. </p>
    
    <hr>

    <h2 id='II'>II. Променливи</h2>
    <p><b>Коментар. </b></p>
    <p>В C# двойната наклонена черта (<b>//</b>) се използва за обозначаване на коментар
      от един ред. Всичко, написано след <b>//</b> на същия ред, се счита за коментар
      и се игнорира от компилатора. Коментарите се използват за добавяне на обяснителен
      или описателен текст в кода, така че разработчиците да разберат по-добре кода.
      Те не се изпълняват като част от програмата.</p>
    <p>Ето няколко примера за едноредови <b>коментари:</b></p>
<pre class='pre'>
// Това е коментар

<span class='grn'>int</span> <span class='blu'>x</span> = <span class='red'>10</span>;      // Декларация на променлива с име <span class='blu'>x</span> от тип <span class='grn'>int</span>, 
                 // инициализирана със стойност <span class='red'>10</span>
                 
<span class='grn'>int </span><b>sum </b>= <span class='blu'>x</span> + <span class='ora'>5</span>; // Изчисляване на променливата <b>sum</b>; 
                 // стойността на <b>sum </b>е: 15 /<span class='red'>10</span>+<span class='ora'>5</span>/
</pre>
    <p>Едноредовите коментари са ограничени до един ред код. Ако трябва да добавите
      коментар, който обхваща няколко реда, можете да използвате <b>/*</b>многоредов
      коментар<b>*/ </b>:</p>
<pre class='pre'>
<b><span class='red'>/*</span></b> Това е многоредов коментар.
   Може да обхваща няколко реда.
   Този и горните 2 реда са многредов коментар.  <b><span class='red'>*/</span></b>
</pre>
    <p><b>Типове данни</b></p>
    <p><b>Целочислени типове - Естествени цели числа</b></p>
    <p><b>byte</b>: Представлява 8-битово цяло число без знак със стойности в диапазона
      от 0 до 255.</p>
    <p><b>int</b>: Представлява 32-битово цяло число със знак със стойности, вариращи
      от -2,147,483,648 до 2,147,483,647. Пример: int x = 10;</p>
    <p><b>Дробни числа</b></p>
    <p><b>float</b>: Представлява число с плаваща запетая с единична точност /32 бита/
      с приблизително 7 цифри точност. Пример: float pi = 3.14;</p>
    <p><b>double</b>: Представлява число с плаваща запетая с двойна точност /64 бита/
      с приблизително 15-16 цифри на точност.</p>
    <p><b>decimal</b>: Представлява десетично число с плаваща запетая с висока точност
      и широк диапазон от стойности. Често се използва за <b>финансови </b>и <b>парични </b>изчисления,
      които изискват точно десетично представяне.</p>
    <p><b>Знакови типове</b></p>
    <p><b>char</b>: Представлява един Unicode знак : 'а', 'в' , 'w', '7', '$', '#' -
      може да бъде всеки знак наличен на клавиатурата,напр:  char ch = '№';</p>
    <p><b>string</b>: Представлява последователност от знаци /<b>char</b>/ и се използва
      за съхраняване и манипулиране на текст в C# - например: string s = "Hold
      my beer";</p>
    <p><b>Булев тип</b></p>
    <p><b>bool</b>: Представлява логическа булева стойност, която може да бъде <b>true</b>
    /истина/ или <b>false</b> /лъжа/. Обикновено се използва за логически операции
      и логически изрази в C#.</p>
    <p>Тези типове представят различни видове данни за съхраняване и работа, като цели
      числа, числа с плаваща запетая, знаци и текст.</p>
    <p><b>Виждал съм, ама няма /void/</b></p>
    <p><b>void - </b>без указан тип; функции /по-соро един вид процедури/ декларирани
      като <b>void</b> не връщат резултат/стойност с <b>return. </b></p>
    <p><b>var</b> - Ключовата дума <b>var</b> в C# се използва за деклариране на променливи,
      без да се задава специфичен тип. Компилатора автоматично определя типа въз
      основа на стойността, присвоена на променливата, и типа не може да се променя
      - примерно не можете първо да присвоите число, а след това да въведете низ.
      Задължително трябва да бъде инициализирана при декларацията си: <b>var </b>myString
      <b>= </b>"Hold my beer";</p>
    <p><b>Декларация на променлива</b></p>
    <p>Декларацията на променлива се състои в следното:</p>
    <p><b><span class='grn'>тип_на_променлива</span></b><b> <span class='red'>име_на_променлива</span>;</b></p>
    <p><b><span class='grn'>тип_на_променлива</span></b><b> - </b>валиден за езика c#
      тип<b>: byte, int, float, double, decimal, char, string, bool ... </b>други
      типове на c# /или класове, валидни за проекта/; </p>
    <p><b><span class='red'>име_на_променлива - </span></b>не трябва да започва с цифра,
      да съдържа интервал, или да е резервирана в езика ключова дума;</p>
    <p>Декларацията на променлива е подобно на полагането в математиката, след като
      напишете " полагаме <b>z = x</b> ", може да ползвате <b>z</b> на следващите
      редове.</p>
    <p><b>Обхват на променлива</b></p>
    <p>В C# обхватът на локална променлива се определя от блока, в който е декларирана.
      Локална променлива може да бъде достъпна само в рамките на блока, където е
      дефинирана, включително всички вложени блокове в нея. След като се излезе от
      блока, локалната променлива излиза извън обхвата и вече не е достъпна. Ето
      един пример за илюстриране на обхвата на променливата:</p>

<pre class='pre'>
void MyFunction()
<b><span class='blu'>{ // начало на блок в който е декларирана x</span></b>
    int x = 10; //Локална променлива 'x', декларирана във функцията
    if (x &gt; 5)
    <b><span class='red'>{ // начало на блок в който е декларирана y</span></b>
        int y = 20; // <b>Локална променлива 'y', декларирана в блока if</b>
        Console.WriteLine(x); // <b>Достъпна: 'x' е в обхват</b>
        Console.WriteLine(y); // <b>Достъпна: 'y' е в обхват</b>
    <b><span class='red'>} // край на блок в който е декларирана y</span></b>
    Console.WriteLine(x); // <b>Достъпна: 'x' е в обхват</b>
    Console.WriteLine(y); // <b><span class='lil'>ГРЕШКА</span>: 'y' е извън обхвата</b>
<b><span class='blu'>} // край на блок в който е декларирана x</span></b>
</pre>

    <p>В горния пример променливата <b>x</b> е достъпна в цялата функция, защото е декларирана
      във външния блок. Променливата <b>y</b> обаче е достъпна само в рамките на
      <b><span class='red'>{</span></b> блока <b><span class='red'>}</span></b> if,
      защото е декларирана във него. След като излезете от блока if, променливата
      <b>y</b> излиза извън обхвата и вече не е достъпна.</p>
    <p>Важно е да се отбележи, че променливи с едно и също име могат да бъдат декларирани
      в различни блокове и те ще имат отделни обхвати. Всеки блок създава нов обхват
      за променливите, декларирани в него.</p>
    <p>Локални променливи със същото име не могат да бъдат декларирани два пъти в един
      и същ обхват. Например, не можете да направите това:</p>
<pre class='pre'>
int x = 20;

// ... код ... ;
 
x = 30; // OK, x присвоява 30 

<span class='red'>int</span> x = 30; // не е ОК, защото има int, т. е. декларираме x отново 
</pre>
      <p>Ето още един пример:</p>
<pre class='pre'>
int p = 20;

for (int i = 0; i &lt; 10; i++) 
{
    int i = 50; // НЕ може да се прави това — i все още е в обхвата
    int p = 40; // НЕ може да се прави това — p все още е в обхвата
    p = 30;     // това може да се прави — променяме стойността в 
                // променливата p, от 20 става 30 
    Console.WriteLine(p + i);
}
</pre>
    <p>Ако се опитате да компилирате това, получавате грешка като следната:</p>
    <p><b>грешка
      CS0136</b>: Променлива с име "i" не може да бъде декларирана в този обхват,
      защото това име се използва в обхващащ локален обхват за дефиниране на локална
      променлива или параметър</p>
    <p>Това се случва, защото променливата <b>i</b>, е дефинирана преди началото на
      for оператора, все още е в обхвата на for и няма да излезе от обхвата, докато
      оператора for не приключи изпълнение. Компилаторът няма начин да направи разлика
      между тези две променливи, така че няма да позволи втората да бъде декларирана.</p>
    <p><b>Константи</b></p>
    <p>В C# константата е стойност, която не може да се променя по време на изпълнение
      на програма. Тя се декларира с помощта на ключовата дума <b>const</b> и трябва
      да и бъде присвоена стойност по време на декларирането. Ето някои ключови точки
      относно константите:</p>
    <p>• Декларация на константа: Константите се декларират с помощта на ключовата дума
      const, последвана от типа данни и името на константата. Например: const int
      MAX_VALUE = 100;.</p>
    <p>• Присвояване на стойност: на константите трябва да бъде присвоена стойност по
      време на декларирането и тази стойност не може да бъде променена по-късно в
      програмата. Например, const double PI = 3.14159;</p>
    <p>• Типове данни: Константите могат да бъдат декларирани с всеки валиден C# тип
      данни, включително числови типове, низове, знаци, булеви стойности и т.н.</p>
    <p>• Конвенция за именуване: По конвенция имената на константите обикновено се изписват
      с главни букви с думи, разделени с долна черта. Например const int MAX_COUNT
      = 10;.</p>
    <p><b>Употреба</b>: Константите са полезни, когато имате стойност, която трябва
      да остане същата в цялата програма и не трябва да се променя случайно. Те могат
      да осигурят смислени имена на важни стойности и да подобрят четливостта на
      кода.</p>
    <p><b>Обхват</b>: Константите имат блоков обхват, което означава, че са достъпни
      само в рамките на блока код, в който са дефинирани.</p>
    <p>Константи по време на компилиране срещу само за четене: Константите се различават
      от променливите само за четене /<b>readonly</b>/ по това, че стойностите на
      променливите само за четене /<b>readonly</b>/ могат да бъдат присвоени по време
      на изпълнение, докато константите се заместват с техните стойности по време
      на компилиране.</p>
    <p><b>пример, демонстриращ използването на константи:</b></p>
    
<pre class='pre'>
class Program
{
    
    <b>const </b>double PI = 3.14159;
    <b>const </b>int MAX_VALUE = 100;
    
    static void Main()
    {
        Console.WriteLine($"The value of PI is: {<b>PI</b>}");
        Console.WriteLine($"The maximum value is: {<b>MAX_VALUE</b>}");
    }
    
}

// Резултат:
// The value of PI is: 3.14159
// The maximum value is: 100
</pre>
    <p>В горния пример константите <b>PI</b> и <b>MAX_VALUE</b> са декларирани и използвани
      в рамките на метода <b>Main</b>. Веднъж присвоени, техните стойности не могат
      да бъдат променяни по време на изпълнение на програмата. Константите са полезни
      за предоставяне на смислени имена на важни стойности, подобряване на четимостта
      на кода и гарантиране, че специфичните стойности остават постоянни в цялата
      програма.</p>
    
    <p><b>Забелжка</b>: реда Console.WriteLine(<b>$</b>"вие въведохте: <b>{a}</b>");
      се нарича интерполация на низ. Знакът <b>$</b> преди "вие въведохте: {a}",
      означава това, което е в <b>{</b>скоби<b>}</b> в низа да се замести със стойността
      на променливата, тоест <b>{a}</b> да се замести със стойността на променливата
      с име <b>а</b>.</p>
      
    <p><b>Константа null</b></p>
    <p>В C# нулевата константа е представена от ключовата дума <b>null</b>. Използва
      се, за да посочи липсата на стойност или че променлива от тип обект не препраща
      към обект. Ето няколко ключови момента относно нулевата константа:</p>
    <p>• <b>null</b> не е валидна стойност за типове стойности (като int, bool и т.н.),
      но може да бъде присвоена на всяка променлива от референтен тип.</p>
    <p>•Когато на променлива е присвоена стойност <b>null</b>, това означава, че тя
      <b>не</b> препраща към обект в паметта.</p>
    <p><b>null</b> може да се използва за различни цели, като инициализиране на променливи,
      указване на неинициализирано състояние или проверка за нулеви условия преди
      достъп до членове или извикване на методи на обекти.</p>
    <p><b>Прощаване с null</b></p>
    <p>Операторът <b><span class='red'>!</span></b> се нарича <b>null-forgiving</b>      
      оператор /оператор опрощаващ <b>null</b>/. Използва се за потискане на предупреждения
      за нулева препратка от компилатора. Ето някои важни подробности:</p>
    <p>• Операторът за прощаване на null казва на компилатора да приеме, че израз или
      променлива никога няма да бъде null, дори ако статичният анализ предполага
      друго.</p>
    <p>• Обозначава се с поставяне на <b><span class='red'>!</span></b> след израза
      или променливата, като: <b>myVariable! </b></p>
    <p>Използването на оператора за опрощаване на <b>null</b> може да бъде полезно,
      когато знаете със сигурност, че дадена стойност няма никога да бъде <b>null</b>,
      но бъдете внимателни, тъй като премахва нулевите проверки за безопасност по
      време на компилация. Ако стойността действително се окаже <b>null</b> по време
      на изпълнение, ще бъде хвърлено изключение <b>NullReferenceException</b>.</p>
    <p>Важно е да се отбележи, че използването на оператора за опрощаване на <b>null</b>      
    трябва да се прави разумно и само когато сте абсолютно сигурни, че няма да
      се появят <b>null</b> стойности. Като цяло е по-добре да се осигури правилна
      проверка и обработка на <b>null</b>, за да се избегнат потенциални изключения
      по време на изпълнение.</p>
    <p><b>Присвояване</b> (<span class='red'><b>!!!</b></span><span class='red'> = ➜ чете се <b>присвоява !!!</b></span><b>)</b></p>
    <p>При декларация на променлива може да й се зададе начална стойност:</p>
<pre class='pre'>
int a <b><span class='red'>=</span></b> 10;  // <b><span class='red'>=</span></b> ➜ <b>оператор <span class='red'>присвоява; чете се 'а присвоява десет'</span></b>
char ch = ‘№’;
float pi = 3.14;
</pre>
    <p>Знакът <b><span class='red'>=</span></b> се нарича <span class='red'>присвоява </span>и
      означава, че стойността на променливата <b>а</b> се задава да е числото <b>10</b>.</p>
    <p>Ако началната стойност на променливата не е зададена, тя се установява на произволно
      число (или произволен знак, ако променливата е тип char).</p>
    <p>Възможно е присвояването на стойност на дадена променлива да се извърши отделно
      от декларирането и:</p>
<pre class='pre'>
float euler; 
euler = 2.71;
</pre>
    <p><b>Операции с числени променливи</b></p>
    <p>В други случай променливата директно присвоява стойност, която е сума или произведение
      на стойности или променливи, напр.:</p>
<pre class='pre'>
int a, b = 10;
a = 20 + b;
</pre>
    <p>След изпълнение на горното действие, стойността в променливата <b>а</b> е <b>30</b>.</p>
    <p>Допустими са следните <b>Аритметични оператори </b>в езика С#:</p>
    <p>• <b>+</b> ➜ Събиране  </p>
    <p>• <b>-</b> ➜ Изваждане  </p>
    <p>• <b>*</b> ➜ Умножение  </p>
    <p>• <b>/</b> ➜ Деление </p>
    <p>• <b>%</b> ➜ Остатък от целочислено делене (само за типа <b>int</b>/<b>byte</b>)</p>
    <p>Посочените операции са бинарни, т.е. изискват два операнда: ляв и десен. Остатъкът
      от целочислено деление се прилага само върху целочислени типове.</p>
    <p><b>Операции с Низове</b></p>
    <p>Съединяване на 2 низа ➜ оператор <b><span class='red'>+</span></b> :</p>
<pre class='pre'>
string str1 = "Hold";
string str2 = "my beer";
string result = str1 <b><span class='red'>+</span></b> " " <b><span class='red'>+</span></b> str2; // " " - интервал
Console.WriteLine(result); 

// резултат: 
// <b>Hold my beer</b>
</pre>
    <p><b>Низ1 еднакъв ли е на Низ2?</b></p>
<pre class='pre'>
string str1 = "Hold my";
string str2 = "Beer";

if (str1 == str2)
{
    Console.WriteLine("Низовете са еднакви.");
}
else 
{   
    // изпълнява се else, защото "Hold my" <b>различно от</b> "Beer"
    Console.WriteLine("Низовете <b>не</b> са еднакви.");
}

// Резултат:
// Низовете не са еднакви.
</pre>
    <p>В горния пример операторът <b>== <span class='red'>(!!! == се нарича равно !!!)</span></b>      
      се използва за сравняване на str1 и str2. Ако низовете са равни, ще се отпечата
      „Низовете са еднакви“. В противен случай ще се отпечата „Низовете не са еднакви“.</p>
    <p>Имайте предвид, че операторът == сравнява съдържанието на низовете, тоест </p>
    <p>"Hold" == "hold" ➜ дава резултат лъжа, защото "<b>H</b>old"
      започва с главна буква, а "<b>h</b>old" - не.</p>
    <p> Ако искате да извършите сравнение без значение дали буквите са малки или главни,
      можете да използвате метода <b>String.Equals</b> със съответните параметри,
      по този начин:</p>
<pre class='pre'>
string str1 = "Hold";
string str2 = "hold";

if (string.Equals(str1, str2, StringComparison.OrdinalIgnoreCase)) // <b>изпълнява се</b>
{   
    // <b>за разлика от предишния пример, вече: "Hold" == "hold", защото не се </b>
    // <b>взима предвид големината на буквите </b>
    Console.WriteLine("Низовете са еднакви. (Главна/Малка буква нечувствителни)");
}
else
{
    Console.WriteLine("Низовете не са еднакви (Главна/Малка буква нечувствителни).");
}

// Резултат:
// Низовете са еднакви. (Главна/Малка буква нечувствителни)
</pre>
    <p>В последния пример методът <b>String.Equals</b> се използва с параметъра 
      <b>StringComparison.OrdinalIgnoreCase</b>      
      за извършване на сравнение между <b>str1</b> и <b>str2</b> без значение дали
      букви са малки или големи.</p>
    <p><b>Полезни методи </b>на обектът string работа със символни низове:</p>
    <p>str1.<b>StartsWith</b>: Проверява дали низът започва с определен подниз.</p>
    <p>str1.<b>EndsWith</b>: Проверява дали низът завършва с определен подниз.</p>
    <p>str1.<b>Contains</b>: Определя дали в низа присъства подниз.</p>
    <p>str1.<b>IndexOf</b>: Връща индекса на първото срещане на определен подниз.</p>
    <p>str1.<b>LastIndexOf</b>: Връща индекса на последното срещане на определен подниз.</p>
    <p>str1.<b>Substring</b>: Извлича подниз въз основа на посочения начален индекс и дължина по избор.</p>
    <p>str1.<b>Replace</b>: Заменя всички срещания на определен подниз с друг подниз.</p>
    <p>str1.<b>ToUpper</b>: Преобразува низа в главни букви.</p>
    <p>str1.<b>ToLower</b>: Преобразува низа в малки букви.</p>
    <p>str1.<b>Trim</b>: Премахва интервалите от низа.</p>
    <hr>
    <p><b>Задачи</b></p>
    <p><b><span class='grn'>Задачи символни низове - в следващата тема</span> /<a href='#III' class='lnk'>III. Управляващи инструкции</a>/ </b></p>
    <p><b>Копиране на репозитори от github</b>:</p>
    <p>Отворете Codespaces, от миналия път.</p>
    <p>Създайте /<b>mkdir</b>/ директория <b>copy</b>, влезте в нея с <b>cd copy</b>      </p>
<pre class='pre'>
git clone https://github.com/404joe/csharp.git
</pre>
    <p>за да копирате целия проект от примерите на курса</p>
    <p>Алтернативно </p>
<pre class='pre'>
curl -O https://raw.githubusercontent.com/404joe/csharp/master/_examples/L-01-1-holdmybeer/Program.cs
curl -O https://raw.githubusercontent.com/404joe/csharp/master/_examples/L-01-1-holdmybeer/holdmybeer.csproj
</pre>
    <p>за да копирате само 2-та файла от проекта <b>hello</b></p>
    <p>Изпълнете:</p>
    <p>$<b>dotnet build</b></p>
    <p>$<b>dotnet run</b></p>
    <p><b>Четене на променлива тип int /цяло число/ от конзолата в променливата <span class='red'>а</span>:</b></p>
<pre class='pre'>
Console.WriteLine("Enter a = ");
int a = int.Parse(Console.ReadLine());

// или следното за дробно число
Console.WriteLine("Enter a = ");
double a = double.Parse(Console.ReadLine());
</pre>
    <p><b>Задачи Променливи</b></p>
    <p>1. Напишете програма, която приема две цели числа <b>a</b> и <b>b</b> от потребителя
      и извежда тяхната сума, разлика и произведение.</p>
    <p>2. Напишете програма, която взема температура в Целзий и я преобразува във Фаренхайт.
      Формулата за преобразуване е: </p>
    <p>TF = ( TC * 9/5) + 32 </p>
    <p>където: TF - Tемпература във Фаренхайт /изчислява се и се извежда на екрана/; TC - Tемпература
      в Целзий /въвежда се от терминала/ </p>
    <p>3. Да се напише програма за определяне на:</p>
    <p>• периметъра на триъгълник, при въведени дължини на страните a, b и c.</p>
    <p>• лицето на триъгълник, при въведена дължина на една от страните a и височина
      към нея h.</p>
    <p>• лицето чрез Хероновата формула: s = sqrt( p * ( p - a ) * ( p - b) * ( p -
      c ) ); p = ( a + b + c ) / 2.</p>
    <p><b>Упътване</b>: функцията Math.Sqrt(number); - корен квадратен, примерно Math.Sqrt(16) ➜ 4;</p>
    <p>4. Да се напише програма, която изчислява обема на триъгълна пирамида по формулата:
      v = s*h*1/3, като от клавиатурата се въвеждат:</p>
    <p>• лицето на основата s и височината h на пирамидата;</p>
    <p>• дължината на страните на основата a, b и c /в случая s се изчислява по Хероновата
      формула от задача 3/ и височината h на пирамидата</p>
    <p>5. Да се напише програма за изчисляване на разстоянието между две точки с дадени
      координати A(x1, y1) и B(x2, y2). Въвеждат се x1, y1, x2, y2</p>
    <p>6. Да се напише програма, в която се въвеждат:</p>
    <p>• две числа</p>
    <p>• три числа</p>
    <p>а тя извежда стойността на най–голямото от тях .</p>
    <p><b>Упътване</b>: Math.Max(5, 8) ➜ резултат: 8</p>
    <p>7. Да се напише програма, в която се въвежда ъгъл в градуси, а тя отпечатва неговия
      синус.</p>
    <p><b>Упътване</b>: </p>
<pre class='pre'>
double degrees = 45.0;
double radians = degrees * (Math.PI / 180.0);
double sine    = Math.Sin(radians);
Console.WriteLine(sine);
</pre>
    <p>8. Имате банкноти по 1$, 2$, 5$ в неограничено количество. Да се напише програма,
      която да разпределя въведена от клавиатурата сума така, че да се състои от
      най-малко количество банкноти.</p>
    <hr>
    
    
    <h2 id='III'>III. Управляващи инструкции: if × for </h2>
    <p><b>УПРАВЛЕНИЕ НА ПОТОКА НА ИЗПЪЛНЕНИЕ НА ПРОГРАМАТА</b></p>
    <p>Този раздел разглежда изразите, които ви позволяват да контролирате потока на
      изпълнение на вашата програма. С оператор за условен преход - изрази като операторите
      <b>if</b> и <b>switch</b>, можете да разклоните кода си в зависимост от това
      дали определени условия са изпълнени. Можете да повтаряте изрази с оператори
      for, while и foreach.</p>
    
    <p><b>Логически изрази</b></p>
    <p>Логическите изрази са съставени от променливи или стойности, свързани по между
      си с логически оператори. Логическите изрази в информатиката дават като резултат
      една от две възможни стойности: истина-<b>true</b> (в езика С съответства на
      число различно от нула, едно по подразбиране) или лъжа-<b>false</b> (в езика
      С съответства на числото нула). Бинарните логически оператори работят върху
      две стойности, докато унарните (само оператор not) работи само върху една стойност.
      <b>Логическите оператори</b> са следните:</p>
    <p><b>! (NOT) </b>оператор: Той инвертира логическата стойност на израз. Ако имаме
      израз който е true, то ! го прави false; ако изразът е false то ! го прави го true.</p>
    <p>bool а = true;</p>
    <p>bool b = !a; // b == false;</p>
    <p><b>&amp;&amp;
      (AND)</b> оператор: Той изпълнява логическа операция И между два израза. Връща
      <b>true</b>, ако и двата израза са <b>true</b>, и <b>false </b>в противен случай.</p>
    <p><b>|| (ИЛИ)</b> оператор: Той изпълнява логическа операция ИЛИ между два израза.
      Връща <b>true</b>, ако поне един от изразите е <b>true</b>, и <b>false</b>,
      ако и двата израза са <b>false</b>.</p>
    <p><b>^ (XOR) </b>оператор: Той изпълнява логическа операция XOR (изключващо ИЛИ)
      между два израза. Връща true, ако изразите имат различни логически стойности
      (единият е <b>true</b>, а другият е <b>false</b>) и <b>false</b>, ако изразите
      имат една и съща логическа стойност (и двата <b>true</b> или и двата <b>false</b>).</p>
    <p>Логически оператори за <b>отношение</b>:</p>
    <p>При конструиране на логически изрази, когато е необходимо да се сравняват стойности
      или стойности на променливи от числен тип се използват оператори за отношение
      в езика С, резултатът от изпълнението на които също е <b>true </b>или <b>false</b>:</p>
    <p><b>a == b </b>връща<b>
      true, </b>ако <b>a </b>e <b>Равно </b>на <b>b</b></p>
    <p><b>a != b </b>връща<b>
      true, </b>ако <b>a </b>e <b>Различно </b>от <b>b</b></p>
    <p><b>a &gt; b </b>връща<b>
      true, </b>ако <b>a </b>e По-голямо от <b>b</b></p>
    <p><b>a &lt; b </b>връща<b>
      true, </b>ако <b>a </b>e По-малко от <b>b</b></p>
    <p><b>a &gt;= b
      </b>връща<b> true, </b>ако <b>a </b>e По-голямо или равно на <b>b</b></p>
    <p><b>a &lt;= b
      </b>връща<b> true, </b>ако <b>a </b>e По-малко или равно на <b>b</b></p>
    <p><b>Опертатор
      if</b></p>
    <p>Операторът <b>if
      </b>ви позволява да изпълните условно блок от код, ако даден логически израз 
        е изпълнен /със стойност true /.
<pre class='pre'>
if (<span class='grn'>логически_израз</span>) 
<b><span class='red'>{</span></b> 
    изпълнва се ако <span class='grn'>логически_израз</span> е със стойност <b>true</b> 
<b><span class='red'>}</span></b>
</pre>    

    <p>Например:</p>
<pre class='pre'>
int a = -120; <b>//</b>минус 120

if (a &gt; 0)
{
    // Кода се изпълнява ако а е положително, в случая не се изпълнява, 
    // защото а == -120,
    // <span class='grn'>логически_израз:</span> <b>a &gt; 0</b> ➜ -120 &gt; 0 ➜ <b>false</b>
}
</pre>    
    
    <p>Операторът <b>if-else:</b></p>
    <p><b>if/else оператор
      </b>- разширява if оператора, като предоставя алтернативен блок от код за изпълнение,
      ако условието е false /стойност false/. Позволява ви да управлявате два различни
      случая. Например:</p>
<pre class='pre'>
<b>a = -120; // </b>минус 120

<b>if (a &gt; 0)</b>
<b>{</b>
    // не се изпълнява, защото а == -120,
    // <span class='grn'>логически_израз:</span> <b>a &gt; 0</b> ➜ -120 &gt; 0 ➜ <b>false</b>
<b>}</b>
<b>else</b>
<b>{</b>
    // изпълнява се само когато а &gt; 0 е със стойност false
    // <span class='grn'>логически_израз:</span> a &gt; 0 ➜ -120 &gt; 0 ➜ false
    // следователно ще се изпълни, защото а &gt; 0 не се изпълнява, 
    // тоест, когато а &lt; 0 или а ==0
<b>}</b>
</pre>    
    <p><b>if / else if / ... / else if / else</b> оператор: този оператор ви позволява да обработвате множество
      <span class='grn'>логически_изрази </span>последователно. Всеки логически израз се
      оценява един по един и съответният блок от код се изпълнява за първия 
      <span
      class='grn'>логически_израз</span>, който се оцени като <b>true</b>. Ако нито един от
        <span
        class='grn'>логическите израз</span> с <b>if</b> не е изпълнен (<span class='grn'>логически_изрази == </span><b>false</b>),
          блокът else се изпълнява като резервен вариант. Например:</p>

<pre class='pre'>
<b>int a = -120;</b>

<b>if (<span class='grn'>a &gt; 0</span>) 
<span class='grn'>{</span>
    // <span class='grn'>{</span>блок </b><b>№</b><b>1 на if<span class='grn'>}</span></b>
    <b>//</b> не се изпълнява, защото а == -120; <span class='grn'>а &gt; 0 </span>➜<span class='grn'>-120 &gt; 0</span> ➜ <b>false</b>
    Console.WriteLine("а е положително число");
<b><span class='grn'>}</span></b> 
else if (<span class='blu'>a == 0</span> ) 
<b><span class='blu'>{</span></b> 
    <b>// <span class='blu'>{</span>блок </b><b>№</b><b>2 на if<span class='blu'>}</span></b>
    // не се изпълнява, защото а == -120; <span class='blu'>а == 0</span> ➜ <span class='blu'>-120 == 0</span> ➜ <b>false</b>
    Console.WriteLine("а е нула");
<b><span class='blu'>}</span></b> 
else 
<b><span class='red'>{</span> 
    // <span class='red'>{</span></b>блок else на if<b><span class='red'>}</span></b>
    // изпълнява се, защото а == -120; и нито <span class='grn'>а &gt; 0</span> е изпълнено; нито <span class='grn'>а == 0</span> е изпълнено
    // следователно не е необходима и проверка за а &lt; 0, защото, ако не е нула и не 
    // е положително, остава да бъде отрицателно 
    Console.WriteLine("а е отрицателно число");
<b><span class='red'>}</span></b>

// Резултат:
// а е отрицателно число
</pre>

    <p><b>Важно: </b>В конструкциите <b>if(...) <span class='blu'>{</span> действие1;
      действие2; <span class='blu'>}</span>, </b>скобите <b><span class='blu'>{} </span></b>могат
      да бъдат изпуснати, но само когато в тях има само едно действие: { <b>действие1<span class='red'>;</span> </b>}<b> </b>&lt;-
      само една<b> <span class='red'>;</span> в {}. </b>Тогава записа става : <b>if(...)
      действие1; </b></p>
      
    <p><b>Съкратен оператор за условен преход /тринарен оператор/</b></p>
    <p>Съкратения оператор за условен преход, който до известна степен замества операторът
      if и е удобен в някои случаи, като например при проверка на стойностите на
      променливи:</p>
    <p>Променлива = (<span class='grn'>логически_израз</span>) ? стойност която се връща
      ако <span class='grn'>логически_израз</span> е <b>true</b> </p>
    <p>               : стойност която се връща ако <span class='grn'>логически_израз</span>      е <b>false</b>;</p>
    <p><b>Пример:</b></p>
<pre class='pre'>
int a;

а = 5 &gt; 3 ? 10 : 20; // a == 10
</pre>

    <p>Стойността на <b>а </b>след изпълнение на горния ред е <b>10</b>, защото 5 винаги
      е по–голямо от 3 (<b>true</b>), следователно се връща първата стойност (10). При
      алтернативното:</p>
<pre class='pre'>
int a; 

а = 5 &lt; 3 ? 10 : 20; // a == 20
</pre>

    <p>стойността на <b>а</b> става <b>20</b>. Числата в горните два примера могат да
      бъдат заместени и от променливи.</p>
    <p><b>Оператор
      switch</b></p>
    <p>Подобно на оператора if, този оператор служи за избор на един от няколко възможни
      варианта. Синтаксисът му може да бъде показан от следния пример: Да се напише
      програма, в която се въвежда цяло число в интервала [1, 7 ], а програмата извежда
      обратно съответен ден от седмицата.</p>
      
<pre class='pre'>
int day = 3; 

switch ( day ) 
{        
    case  1 : Console.WriteLine("понеделник"); break; 
    case  2 : Console.WriteLine("вторник");    break;    
    case  3 : Console.WriteLine("сряда");      break;
    case  4 : Console.WriteLine("четвъртък");  break;
    case  5 : Console.WriteLine("петък");      break;
    case  6 : Console.WriteLine("събота");     break;
    case  7 : Console.WriteLine("неделя");     break;
    default : Console.WriteLine(" числото не е в интервала [1, 7 ]"); break;
}  

// Резултат: 
// <b>сряда</b> // защото променливата day == 3 
</pre>

    <p>switch е ключова дума, а променливата която е в кръглите скоби може да е и от
      тип <b>char
      </b>(или <b>int </b>- цяло число).</p>
    <p>Изпълнението му протича по следния начин: Последователно се проверява дали стойността
      на променливата (в кръглите скоби) съвпада със стойностите на константите (или
      променливите) след клаузите <b>case</b>. В случай на съвпадение се изпълнява
      съответната последователност от инструкции (в случая да се отпечата съответния
      ден от седмицата ). Командата break предизвиква прекъсване изпълнението на
      инструкцията switch, при което изпълнението се прехвърля след затварящата фигурна
      скоба } на оператора switch. Клаузата default не е задължителна. Ако я има,
      тя се изпълнява при условие, че стойността на израза не съвпада с нито една
      от изброените след case стойности (или променливи).</p>
    <p>Програма, в която се въвежда число (от 1 до 12) – номер на месец, а програмата
      показва в кой сезон попада:</p>
<pre class='pre'>
int month = 5;

switch(month) 
{       
    case 12 : case  1 : case  2 : Console.WriteLine(" Зима   "); break;
    case  3 : case  4 : case  5 : Console.WriteLine(" Пролет "); break;    
    case  6 : case  7 : case  8 : Console.WriteLine(" Лято   "); break;
    case  9 : case 10 : case 11 : Console.WriteLine(" Есен   "); break;
    default : Console.WriteLine&lt;&lt;"Въведения месец не е в интервала [1, 12] "; break;
}  

// Резултат: 
// Пролет
</pre>

    <p>Kонструкцията</p>
    <p>case  3: case  4: case  5: Console.WriteLine(" Пролет "); break;</p>
    <p>се тълкува от компютъра като: Ако променливата month е 3, или е 4, или е 5 :
      отпечатай – Пролет.</p>
      
    <p><b>Оператор  for</b></p>
    <p>C# предоставя четири различни оператора (<b>for, while,
      do-while и foreach</b>), които ви позволяват да изпълните блок от код многократно,
      докато не бъде определен логически_израз върне <b>false</b>. С ключовата
      дума <b>for </b>преминавате през оператор, чрез който тествате дали логически_израз е 
      <b>true</b>, преди да извършите друга итерация:</p>
      
<pre class='pre'>
for (<span class='red'>int i = 0;</span> <span class='blu'>i &lt; 100;</span><span class='grn'> i++</span>) 
<b><span class='lil'>{</span></b>
    Console.Write(i + " # "); // този ред се повтаря 100 пъти, при първото изпълнение
                              // i == 0 /начална стойност/; при второто i == 1; ... 
                              // при последното изпълнение i == 99,
                              // след <span class='grn'>i++ </span>➜ i == 100, логическия 
                              // израз става 100 &lt; 100 ➜ false ➜
                              // изпълнението спира
<b><span class='lil'>}</span></b>

// Резултат: 
// 0 # 1 # 2 # 3 # 4 # 5 # 6 # 7 # 8 # 9 # 10 # 11 # 12 # 13 # 14 # 15 # 16 # 17 # 
// 18 # 19 # 20 # 21 # 22 # 23 # 24 # 25 # 26 # 27 # 28 # 29 # 30 # 31 # 32 # 33 # 
// 34 # 35 # 36 # 37 # 38 # 39 # 40 # 41 # 42 # 43 # 44 # 45 # 46 # 47 # 48 # 49 # 
// 50 # 51 # 52 # 53 # 54 # 55 # 56 # 57 # 58 # 59 # 60 # 61 # 62 # 63 # 64 # 65 # 
// 66 # 67 # 68 # 69 # 70 # 71 # 72 # 73 # 74 # 75 # 76 # 77 # 78 # 79 # 80 # 81 # 
// 82 # 83 # 84 # 85 # 86 # 87 # 88 # 89 # 90 # 91 # 92 # 93 # 94 # 95 # 96 # 97 # 
// 98 # 99 #
</pre>

    <p>Първият израз на оператора <b>for</b> е <span class='red'>инициализаторът</span>.
      Оценява се преди да се изпълни първото изпълнение. Обикновено се инициализира
      локална променлива като брояч. </p>
    <p>Вторият израз е <span class='blu'>логически_израз_за_изход</span>. Проверява
      се преди всяка изпълнение на блока for. Ако този израз се оцени като <b>true</b>,
      блокът се изпълнява. Ако се оцени като <b>false</b>, операторът <b>for </b>завършва
      и програмата продължава със следващия оператор след затварящата фигурна скоба
      на блока на <b>for </b>➜ след скобата<b> <span class='lil'>}</span> 
      </b>.</p>
    <p>След като блока се изпълни, <span class='grn'>третият
      израз</span>, итераторът, се изпълнява. Обикновено увеличавате брояча на оператора.
      Чрез <b>i++</b> числото <b>1</b> се добавя към променливата <b>i</b>. 
      <b>i++ &#x27F7; i = i + 1 &#x27F7; i += 1; </b>Респективно,
      <b>i += 10</b> увеличава <b>i</b> с <b>10</b>. След третия израз се изчислява
      <span class='blu'>логически_израз_за_изход </span>отново, за да се провери
      дали трябва да се направи ново изпълнение на блока for.</p>
    <p>Оператора <b>for</b> е с предусловие, тъй като <span class='blu'>логически_израз_за_изход </span>се
      оценява преди изпълнението; следователно <b><span class='lil'>{</span></b>
      съдържанието <b><span class='lil'>}</span></b> на / for () <b><span class='lil'>{</span></b>
      ... съдържание ... <b><span class='lil'>}</span></b> / изобщо няма да бъде
      изпълнено, ако логическият израз е със стойност false.</p>
    <p>Може да се влагат <b>for </b>оператори, така че вътрешният оператор да се изпълнява
      веднъж напълно за всяка итерация на външен оператор. Този подход обикновено
      се използва за преминаване през всеки елемент в правоъгълен двумерен масив.
      Най-външният оператор <b>for</b> преминава през всеки ред, а вътрешният оператор
      for преминава през всяка колона в определения ред. Следният код показва редове
      от числа. Той също така използва друг метод на конзолата, <b>Console.Write</b>,
      който прави същото като <b>Console.WriteLine</b>, но не връща каретка към началото
      на реда:</p>

<pre class='pre'>
for (int p = 0; p &lt; 10; p++) 
{
    for (int q = 0; q &lt; 10; q++) 
    {
        int num = (p * 10) + q;
        Console.Write($"{num:D2} "); // :D2 - Отпечатва числото с 
                                     // водещи нули, ако е необходимо
        
        // Забавяне на изпълнението с 
        // 0.2 секунди - 200 милисекунди,
        // за да се получи нещо като анимация
        Thread.Sleep(200);                             
    }
    Console.WriteLine();
}
</pre>

    <p><b>След около 20 секунди /0.2 сек. × 10 × 10 ➜ 20 сек. / Това ще доведе до следния резултат:</b></p>
<pre class='pre'>
00 01 02 03 04 05 06 07 08 09
10 11 12 13 14 15 16 17 18 19
20 21 22 23 24 25 26 27 28 29
30 31 32 33 34 35 36 37 38 39
40 41 42 43 44 45 46 47 48 49
50 51 52 53 54 55 56 57 58 59
60 61 62 63 64 65 66 67 68 69
70 71 72 73 74 75 76 77 78 79
80 81 82 83 84 85 86 87 88 89
90 91 92 93 94 95 96 97 98 99
</pre>   
 
    <p>Всяко число се показва с две цифри / спецификатор <b>:D2</b> / , което гарантира,
      че числата под 10 имат водеща нула.</p>
    <p><b>Console.Write</b> и <b>Console.WriteLine </b></p>
    <p>Разликата между Console.Write и Console.WriteLine е следната:</p>
    
<pre class='pre'>
Console.Write('а');
Console.Write('а');
Console.Write('а'); 

// резултат:
// aaa   
</pre>
    
    <p>При WriteLine:</p>
    <p></p>
<pre class='pre'>
Console.WriteLine('а');
Console.WriteLine('а');
Console.WriteLine('а');

// резултат:
// а
// а
// а
</pre>
    <p>- тоест <b>Console.WriteLine('а');</b> поставя знак за нов ред / "\r\n"  / след 'а', а <b>Console.Write('а'); </b>не
      поставя.</p>
    <p><b>операторът while</b></p>
    <p>Подобно на оператора <b>for, while </b>е оператор с предусловие. Синтаксисът е подобен:</p>
    
<pre class='pre'>
<span class='red'>int i = 0;</span>

while (<span class='blu'>i&lt;100</span>) 
{
   // ... команди ...
   <span class='grn'>i++;</span>
}
</pre>

    <p>За разлика от оператора <b>for</b>, операторът <b>while </b>най-често се използва
      за повтаряне на оператор или блок от оператори /...команди.../ за определен
      брой пъти, които не са известни преди началото на оператора. </p>
    <p><b>операторът do-while </b>е с постусловие. Това означава, че <span class='blu'>логически_израз_за_изход</span>      
      на оператора се оценява след като <b><span class='lil'>{</span></b> блока
      <b><span class='lil'>}</span></b> на оператора е изпълнено. Следователно операторите
      <b>do-while</b> са полезни за ситуации в които блок от изрази трябва да бъде
      изпълнен <b>поне веднъж</b>, както в този пример:</p>
    
<pre class='pre'>
<span class='red'>int state = 1000;</span>

do 
{   
    // Този оператор ще се изпълни поне веднъж, дори ако логическият_израз е със стойност false.
    // Ще се изпълни 1 път; 
    <span class='grn'>state ++; // </span>state == 1001
} while (<span class='blu'>state&lt;100</span>); // 1001 &lt; 100 ➜ <b>false ➜ </b>
                     // изпълнението продължава от следващия ред

Console.WriteLine($"state is: {state}");

// Резултат: 
// state is: 1001
</pre>
      
    <p><b>операторът foreach</b></p>
    <p>foreach от следния код, ако приемете, че <b>intArray </b>е масив от тип <b>int</b>:</p>

<pre class='pre'>
foreach (int variabl in <b>intArray</b>) 
{
    Console.WriteLine(variabl);
}
</pre>

    <p><b>Оператори за прекъсване break
      и continue</b></p>
    <p>Пример който илюстрира приложението на операторите за прекъсване на итеративен
      оператор <b>break</b> и техника за използване на безкраен итеративен оператор
      са представени в следната задача: Да се направи програма, в която се въвежда
      число, а тя го извежда обратно на екрана, докато се въведе числото 0:</p>

<pre class='pre'>
int a;        

do 
{
    Console.WriteLine(" въведете число; въведете 0 за край");
    a = int.Parse(Console.ReadLine());
    if ( a == 0 ) 
    {
        break; //  прекъсва while, ако се въведе 0 за а
    }
    Console.WriteLine($"вие въведохте: {a}");
} while ( true ); // true – логически израз, винаги със стойност true

// Резултат:
// въведете число; въведете 0 за край
// 5
// вие въведохте: 5
// въведете число; въведете 0 за край
// 6
// вие въведохте: 6
// въведете число; въведете 0 за край
// 0
</pre>    

    <p>Решението на задачата може да бъде реализирано и чрез оператора за прескачане
      към следващата итерация <b>continue</b>:</p>

<pre class='pre'>
int a;

while ( true ) // <span class='red'>{</span> блок на while, повтаря се до безкрайност <span class='red'>}</span>
<b><span class='red'>{ </span>          </b>
              
    <span class='blu'>Console.WriteLine("въведете число; въведете 0 за край");</span>
    a = int.Parse(Console.ReadLine());
    <span class='grn'>if ( a != 0 )</span> <span class='grn'>{ </span>// ако е въведено <b>0</b> за <b>а</b>, не се 
                    // изпълняват действията в скобите<span class='grn'> { ... }</span>
        Console.WriteLine($" вие въведохте: {a}");
        
        <b>continue</b>; //  преминава към сл. итерация, 
                  //  т. е. <span class='blu'>Console.WriteLine("въведете...</span>
    <span class='grn'>}</span>
    
    <b>break</b>; // прекъсва while, ако a == 0, защото <span class='grn'>if (a!=0)</span> не се изпълнява, 
           // тоест не се изпълнява <b>continue</b>.
<b><span class='red'>}</span></b>

// Резултат:
въведете число; въведете 0 за край
5
вие въведохте: 5
въведете число; въведете 0 за край
6
вие въведохте: 6
въведете число; въведете 0 за край
0
</pre>


    <p><b>Побитови оператори</b></p>
    <p>Ето кратко резюме на побитовите оператори в C#:</p>
    <p><b>бит</b> - единица за информация имаща стойност <b>1 /true/</b> или <b>0 /false/</b></p>
    
    <p><b>&lt;&lt;</b> (преместване наляво): Измества битовете на число наляво с определен
      брой позиции. числото 4, записано двоично е 00000100.  00000100 &lt;&lt; 2
      ще доведе до 00010000. 00010000 <b>=</b> 16 (десетично). <b>&lt;&lt;</b> е
      много полезен за умножение по 2 /или намиране на степени на 2/, тъй като всеки
      път, когато двоичното число се измества наляво 1 позиция, числената му стойност
      се удвоява. </p>
    <p>Например 4 &lt;&lt; 3 = 32, защото 4 &lt;&lt; 3 &#x27F7; 8 &lt;&lt; 2 &#x27F7;
      16 &lt;&lt; 1 = 32; </p>
    <p>Еквивалентно на 4 × (2^3) = 32; </p>
    <p><b>&gt;&gt;</b> (преместване надясно): Измества битовете на число надясно с определен
      брой позиции. Всяко преместване на дясно дели числото на 2. Например:</p>
    <p>00100000 (32 десетично) &gt;&gt; 2 = 00001000 (8 десетично), или:</p>
    <p>32 &gt;&gt; 2 = 16 &gt;&gt; 1 = 8.</p>
    <p><b>|</b> (побитово ИЛИ): Извършва побитова операция ИЛИ върху две числа, като
      задава всеки получен бит на 1, ако поне един от съответните битове е 1.</p>
    <p><b>&amp;</b> (побитово И): Извършва побитова операция И върху две числа, като
      задава всеки получен бит на 1 само ако и двата съответстващи бита са 1.</p>
    <p><b>^</b> (побитово XOR): Извършва побитова операция XOR (изключително ИЛИ) върху
      две числа, като за всеки получен бит се задава 1, ако съответните битове са
      различни.</p>
    <p>Тези оператори работят върху отделни битове от двоични представяния на числа
      и често се използват за битова манипулация на ниско ниво или специфични сценарии,
      изискващи побитови операции.</p>
    <p>Относно побитовите оператори <b>ИЛИ </b>/OR/, <b>Изключващо ИЛИ</b> /XOR/, <b>И </b>/&amp;/
      - те могат да се използват за установяване на отделни битове или за прочитане
      на отделни битове. Битовете са номерирани от дясно наляво, като най-десния
      бит е на позиция 0. Пример: Позиция <span class='red'>0</span>: 0000010<span class='red'>0</span>;Позиция <span class='red'>4</span>:<span class='red'> 
      </span>000<span class='red'>0</span>0100; Позиция <span class='red'>7</span>:
        <span class='red'> 0</span>0000100. По надолу има примери как се използват:</p>
    <p><b>задача 1</b>: Число: 00000<span class='red'>1</span>00. прочетете бит 2 -
      Ако е установен на 1 да се върне true, false ако не е? <b>Решение </b>За да
      прочетем стойността на бит 2 в числото 00000<span class='red'>1</span>00, изместваме
      позицията на числото 2 надясно с помощта на оператора &gt;&gt; и изпълняваме
      побитово <b>И </b>с 0000000<span class='red'>1</span> (десетично 1, нарича
      се още <b>маска</b>). Ако резултатът е 1, битът е установен на 1; ако резултатът
      е 0, битът не е установен и резултата е false:</p>
<pre class='pre'>
int number = 0b00000100;

bool isBitTrue = ((number &gt;&gt; 2) &amp; 1) == 1; 
// isBitTrue ➜ true
</pre>                 
    <p>Променливата <b>isBitTrue </b>ще бъде true, защото битът на позиция 2 в числото
      00000100 е 1.</p>
    <p><b>задача 2</b>: Число: 00000<span class='red'>1</span>00. Установете бит
      <span
      class='red'>2</span> на <span class='red'>0</span>. <b>Решение</b></p>
    <p>За да отменим (зададем на 0) бит 2 в числото 00000<span class='red'>1</span>00,
      можем да използваме побитовия оператор <b>И</b> (&amp;) с битова маска, която
      има 0 в бит 2 и 1 навсякъде другаде /11111<span class='red'>0</span>11/.</p>
<pre class='pre'>
int number = 0b00000100;

int bitMask = ~(1 &lt;&lt; 2);
int result = number &amp; bitMask;
</pre>    
    <p>Стойността на <b>result</b>  ще бъде 0b00000<span class='red'>0</span>00, което
      означава, че битът на позиция 2 е изчистен /зададен на 0/.</p>
    <p><b>задача 3</b>: Число: 000<span class='red'>0</span>0100. Установете бит
      <span
      class='red'>4</span> на <span class='red'>1</span>. <b>Решение</b></p>
    <p>За да установим (зададем на 1) бит 4 в числото 000<span class='red'>0</span>0100,
      можем да използваме побитовия оператор <b>ИЛИ </b>(|) с битова маска, която
      има 1 в бит 4 и 0 навсякъде другаде.</p>
<pre class='pre'>
int number = 0b00000100;

int bitMask = 1 &lt;&lt; 4;
int result = number | bitMask;
</pre>
    <p>Стойността на резултата ще бъде 0b000<span class='red'>1</span>0100, което означава,
      че битът на позиция 4 е установен на 1.</p>
    <p><b>Функции</b></p>
    <p>Функция в програмирането е код, който извършва някаква дейност, и връща резултат,
      например:</p>
<pre class='pre'>
int add(int a, int b) 
{
    return a+b; // връщане на резултат /сумата 
                //   на <b>a</b> и <b>b</b>/ от работата на кода
}
</pre>
    <p>Функцията се извиква чрез нейното име, например : add(10, 15) - &gt; резултата
      25 като число се поставя на мястото от където е извикана функцията; може да
      се извика по следния начин:</p>
    <p>int c = add(15, add(10, 10)); // в променливата <b>c</b> се записва числото <b>35</b>.</p>
    <p>В c# се наричат <b>методи</b>, но това по същество са вид функции.</p>
    <p><b>Функция
      Main - </b> Функцията <b>Main</b> е входна точка за всяка програма; от нея
      започва изпълнението на програмата. Когато програмата се стартира от потребителя,
      операционната система извиква 1 път функцията <b>Main.</b></p>
    <p><b>Рекурсия</b>- когато дадена функция извиква сама себе си. При това се получава
      нещо подобно на итеративен оператор, който има нужда от логически_израз за изход, иначе
      се повтаря безкрайно:</p>

<pre class='pre'> 
public class Program
{
    public static void <b><span class='red'>Main</span></b>()
    {
        Console.WriteLine("Hold my beer");
        <b><span class='red'>Main</span></b>(); // Извикваме функцията Main,
                // която извиква себе си, 
                // отново и отново до безкрайност
    }
}
</pre>

    <p>Ето пример за <b>рекурсивна</b> функция в C# за изчисляване на сумата от числа
      от 1 до 100 /1+2+3+...+99+100/:</p>
      
<pre class='pre'>
public static int <b><span class='red'>SumR</span></b>(int n)
{
    if (n == 1) 
    {   // ако n стигнало до 1, се прекратява 
        // изпълнението; <b>логически_израз за изход</b>
        return 1;
    }
    else 
    {   
        // ако <b>n</b> &gt; <b>1</b>, се връща текущата 
        // стойност на n + <b><span class='red'>SumR</span></b>(n - 1);
        return n + <b><span class='red'>SumR</span></b>(n - 1);
    }
}

// Употреба на <b>рекурсивна</b> функция :
int result = <b><span class='red'>SumR</span></b>(<b>100</b>);
Console.WriteLine(result); 

// Резултат: 
<b>5050</b>
</pre>

    <p>В този пример функцията <b>SumR</b> приема цяло число n като вход и <b>рекурсивно
      </b>изчислява сумата на числата от <b>n</b> до <b>1</b>. логическият_израз за изход
      е <b>n</b> да стане равно на <b>1</b>, тогава функцията връща <b>1</b>. В противен
      случай тя добавя <b>n</b> към резултата и <b>рекурсивно</b> извиква себе си
      с параметър <b>n-1</b>. Накрая извикваме функцията <b>SumR</b> със <b>100</b>
      като вход и отпечатваме резултата.</p>
    <p>Същата задача, решена с оператор<b> for:</b></p>
    
<pre class='pre'>
public static int <b><span class='red'>SumF</span></b>(int n)
{
    int sum = 0;
    
    for (int i = n; i &gt;= 1; i--)
    <b><span class='blu'>{</span></b>
        sum += i; // еквивалентно на <b>sum = sum + i</b>: добавяме <b>i</b> към <b>sum</b>
    <b><span class='blu'>}</span></b>
    return sum;
}

// Употреба на <b>for</b> версията /без <b>рекурсия</b>/:
int result = <b><span class='red'>SumF</span></b>(100);

Console.WriteLine(result); // Резултат: 
<b>5050</b>
</pre>

    <p>В тази версия инициализираме променливата <b>sum</b> с <b>0</b> и използваме
      <b>for</b> оператор за итерация от <b>100</b> до <b>1</b> (включително). <b>for</b>      
      /това, което е в скобите <b><span class='blu'>{ ... }</span></b>/ се повтаря
      в низходящ ред и при всяко повторение стойността на <b>i</b> се добавя към
      променливата <b>sum, </b>след което сойността на <b>i </b>се намалява с <b>1</b>.
      Накрая се връща изчислената сума чрез <b>return</b>. Това постига същия резултат
      като рекурсивната версия, но без използване на рекурсия.</p>
    <hr>
    <p><b>Задачи</b></p>
    <p><b>Задачи Логически изрази</b></p>
    <p>1. Какъв е резултатът от следната операция : ! (a &amp;&amp; 1) при а = 0 ?</p>
    <p>2. Какъв е резултатът от следната операция : ( ( a &lt;= b ) || ( c &gt; d )
      ) при a = 5, b = 7 , c = 4, d = 3?</p>
    <p>3. Какъв е резултатът от следната операция : !( (a &gt; b )&amp;&amp;(a ! = c)
      ), при:</p>
    <p>• a=1; b=2; c=3 ?</p>
    <p>• a=3; b=2; c=1 ?</p>
    <p>4. Да се напише логически израз относно а и b, който:</p>
    <p>•връща true, ако а е в интервала [-3;2] и b е в интервала [5;7]</p>
    <p>•връща false, ако а е в интервала [5;7] или b е в интервала [-3;2]</p>
    <p>5. Да се напише логически израз, който връща true, ако точката А ( x, y) попада
      в окръжността О с радиус R и център C ( a, b)</p>
    <p>6. Да се напише логически израз, който връща true, ако точката А ( x, y) попада
      в правоъгълника ABCD с център O ( p, q) и страни a и b.</p>
    <p>7. Да се напише логически израз, който връща true, ако точката А ( x, y, z )
      попада в сфера с център О ( p, q, r) и радиус R.</p>
    <p><b>Задачи оператори if и switch </b></p>
    <p>1. Да се напише програма, в която от клавиатурата се въвежда цяло число и програмата
      определя дали то е четно или нечетно. Упътване: да се използва оператора %
      за остатък от целочислено делене.</p>
    <p>2. Да се напише програма, в която се въвеждат координатите на две точки А(x1,
      y1) и В (x2, y2) от равнината и програмата определя дали и двете лежат в квадрант
      I</p>
    <p>3. Да се напише програма, при която от клавиатурата се въвежда цяло число [1,
      19], а програмата го извежда с:</p>
    <p>• текст</p>
    <p>• римски цифри</p>
    <p>4. Осите на правоъгълна координатна система в равнината я разделят на 4 квадранта,
      номерирани от 1 до 4. Координатите са целочислени. Да се състави програма,
      в която се въвеждат стойности X и Y (координати на точка) и след това програмата
      дава съобщение в кои квадранти се намира точката.</p>
    <p><b>5.</b> Напишете програма, която приема два низа от потребителя и извежда дали
      са еднакви или не. <b>Упътване: </b>Ползвайте Метода <b>string.Compare:</b></p>
      
<pre class='pre'>
string s1 = "hold my";
string s2 = "beer";

int result = <b>string.Compare</b>(s1, s2);
if (result == 0)
{
    Console.WriteLine("Двата низа са еднакви");
}
else if (result &lt; 0) 
{
    Console.WriteLine("Първия низ е по-малък от втория");
}
else 
{   
    // изпълнява се, ако <b>result &gt; 0, </b>тоест <b>"hold my" &lt;
    // "beer", </b>защото <b>b </b>е преди <b>h</b>
    Console.WriteLine("Първия низ е по-голям от втория");
}

// Резултат:
// Първия низ е по-голям от втория
</pre>

    <p><b>6.</b> Напишете програма, която приема три цели числа от потребителя и извежда
      стойността на най-голямото от трите. </p>
    <p>• Math.Max(5, 7) - &gt; връща 7, по този начин</p>
    <p>• с оператор if</p>
    <p> <b>7. </b>Напишете програма, която приема число от потребителя и извежда дали
      е четно или нечетно. Използвайте оператор за остатък от целочислено делене
      %: 5%2 == 1 (остатък при целичислено делене на 5 на 2); 6%2 == 0; 7 % 2 ==
      1, .... ➜ а%2 == 0 ➜ числото е четно; </p>
    <p><b>8.</b> Напишете програма, която приема две цели числа от потребителя и използва
      итеративен оператор for , за да изведе всички четни числа между тях (включително).</p>
    <p><b>9.</b> Напишете програма, която приема число от потребителя и извежда дали
      е положително, отрицателно или нула.</p>
    <p><b>10.</b> Напишете програма, която приема две числа от потребителя и извежда
      дали първото е по-голямо, по-малко или равно на второто.</p>
    <p><b>11.</b> Напишете програма, която приема низ и отпечатва дължината му.</p>
    <p>string str = "Hold my beer";</p>
    <p>int length = str.Length; // length is 12; str.Count(); ➜ 12</p>
    <p><b>Задачи оператор for/while/do while</b></p>
    <p><b>1. </b>Напишете програма, която приема цяло число N и отпечатва четните числа
      от 0 до N чрез : for / while / do-while. Да се направи да работи обратно, със
      стъпка 0.25 (да се отпечата 25, 24.75, 24.50, … , 1 .25, 1).</p>
    <p>2. Да се напише програма, която определя колко елемента трябва да има сумата:
      1 + 1/2 + 1/3 + 1/4  +...+ 1/N, така че тази сума е да е по-мaлка от 4?</p>
    <p>3. Да се напише програма, която изчислява произведението на две въведени цели
      числа a и b само с действие събиране.</p>
    <p>4. Да се напише програма, която отпечатва на екрана със знак звездичка, точките
      през които минава графиката на функцията: y = f(x) = x ( 80 – x ) / 80 + 1;
      където x принадлежи на интервала [1 .. 80] и е цяло число.  </p>
    <p><b>Упътване:</b></p>

<pre class='pre'> 
int x, y, fx;

for (y = 25; y &gt;= 1; y-- ) 
{
    for (x = 1; x &lt;= 80; x++ ) 
    {
        fx = x * ( 80 - x ) / 80 + 1;
        if (fx == y ) 
        {
            Console.Write("*"); 
        } 
        else 
        { 
            Console.Write(" ");
        }
    }
    
    Console.WriteLine(); // слага нов ред
}
</pre>

    <hr>
        
    <h2 id='IV'>IV. Масиви</h2>
    <p><b>Едномерни масиви</b></p>
    <p>В C# едномерният масив е колекция от елементи от един и същ тип данни, които
      се съхраняват в непрекъснат блок памет - например подобно на поредица от числа, 
      разположени в ред от таблица/. Декларира се с помощта на квадратни
      скоби и определен размер, като този:</p>

<pre class='pre'>
int[] myArray = new int[5];
</pre>    

    <p>Това създава масив с цели числа, наречен myArray с дължина от 5 елемента. Масивът
      може да бъде достъпен с помощта на индексна нотация - myArray[<b>index</b>].
      При това индекса на масива <b>винаги </b>е тип <b>int - </b>цяло число, а първият
      елемент винаги е с индекс <b>0</b> /нула/:</p>

<pre class='pre'>
int[] myArray = new int[5];

myArray[<b>0</b>] = 21;
myArray[<b>1</b>] = 52;
myArray[<b>2</b>] = 12;
myArray[<b>3</b>] = 14;
myArray[<b>4</b>] = 45;
</pre>
    
    <p>Стойностите на елементите на масива могат да се присвояват индивидуално /горния пример/ 
      или чрез итеративен оператор:</p>
      
<pre class='pre'>
int[] myArray = new int[5];

for (int i = 0; i &lt; myArray.Length; i++)
{
    Console.WriteLine($"Enter element[{i}]=");
    myArray[i] = int.Parse(Console.ReadLine());
}
</pre>

    <p>В C# първият елемент от масива винаги е с индекс 0. Последният елемент е с индекс
      array.Length - 1.</p>
    <p>Можете също така да декларирате и инициализирате масив в един израз, като този:</p>
<pre class='pre'>
int[] myArray = {21, 52, 12, 14, 45};
</pre>
    <p>Това създава масив с цели числа, наречен myArray, със същите стойности като в
      предишния пример.</p>
    <p><b>Foreach</b></p>
    <p>Вариант за обхождане на масива е оператора foreach:</p>
    
<pre class='pre'>
int[] myArray = {21, 52, 12, 14, 45};

foreach (int number in myArray )
{
    Console.WriteLine(number + " ; ");
}
</pre>
    
    <p>В този пример имаме целочислен масив с име myArray с пет елемента. Итеративния
      оператор foreach обхожда всеки елемент в масива и го извежда на екрана. Резултатът
      ще бъде:</p>

<pre class='pre'>
21 ; 
52 ; 
12 ; 
14 ; 
45 ; 
</pre>

    <p>Масивите могат да се предават като параметри на методи, а масивите могат да се
      връщат от методи. Те могат да се използват и в комбинация с други типове данни,
      като например в многомерни масиви, назъбени масиви и масиви от обекти.</p>
    <p><b>Алгоритми</b></p>
    <p><b>Сума на елементите на масива /сумиране/</b></p>
    
<pre class='pre'>
int[] myArray = {21, 52, 12, 14, 45};

int sum = 0; // суматор, задължителна инициализация с 0
             // ако суматора не е инициализиран, може да 
             // има произволна стойност и сумата да не е вярна

foreach (int number in myArray )
{
    sum += number;
}

Console.WriteLine("Sum: " + sum);

//Резултатът ще бъде:
Sum: 144
</pre>
    
    <p>Операторът foreach обхожда всеки елемент в масива и го добавя към променливата
      sum. След като foreach завърши, отпечатваме общата сума на конзолата. </p>
    <p>Операторът foreach е удобен начин за итериране на елементите на едномерен масив
      и извършване на операции като сумиране на стойностите.</p>
    <p><b>Намиране на Максимален елемент /филтриране/</b></p>
    
<pre class='pre'>
int[] myArray = {21, 52, 12, 14, 45};

int indmx = 0; // индекс на максималния елемент
               // с нула го насочваме към първия елемент

for (int i = 1; i &lt; myArray.Length; i++)
{
    if (myArray[indmx] &gt; myArray[i] )
    {
        indmx = i;
    }
}

Console.WriteLine($"Max element: myArray [{indmx}] = {myArray [indmx]} " );

// Резултатът ще бъде:
// Max element: myArray [1] = 52
</pre>
    
    <p>В този пример инициализираме променливата indmx с индекса на първия елемент на
      масива /0/. След това преминаваме през останалите елементи на масива с помощта
      на for оператор. Ако елемент с даден индекс /i/ е по-голям от елемента на текущия
      максимален индекс, актуализираме indmx до текущия индекс /indmx = i;/. Накрая
      отпечатваме стойността на максималния елемент.</p>
    <p><b>Отпечатване на четността на
      елементите на масива /филтриране-2/</b></p>
      
<pre class='pre'>
int[] myArray = {21, 52, 12, 14, 45};

for (int i = 1; i &lt; myArray .Length; i++)
{
    Console.WriteLine($"myArray[{i}]=" + myArray[i] + " - " + 
                     (myArray[i] % 2 == 0 ? "even" : "odd"));
}

// Резултат:
// myArray[0] = 21 - odd
// myArray[1] = 52 - even
// myArray[2] = 12 - even
// myArray[3] = 14 - even
// myArray[4] = 45 - odd
</pre>    
    
    <p>В този пример операторът for итерира всеки елемент в масива с числа. Изразът
      за <b>myArray[i] % 2 == 0</b> проверява дали числото е четно, като използва
      модулния оператор (<b>%</b>), за да провери дали има остатък /0/ при разделяне
      на 2. Ако логическият израз е със стойност true, то се отпечатва "четно" /even/; в противен
      случай се отпечатва "нечетно" /odd/.</p>
    <p><b>Сумиране на четни елементи и нечетнио
      елементи /филтриране+сумиране/</b></p>
      
<pre class='pre'>
int[] myArray = {21, 52, 12, 14, 45};

int sumOfOdd = 0;
int sumOfEven = 0;

foreach (int number in myArray)
{
    if (number % 2 == 0) 
        sumOfEven += number; // <b><span class='red'>!!! </span></b>тук скобите {} на if/else бкоковете
    else                     // са нарочно изпуснати, зашото когото в if/else/for блок има            
        sumOfOdd += number;  // само 1 команда/операция/ред, както в случая,
                             // могат да бъдат изпуснати, но <b><span class='red'>само в този случай</span></b>
                             
}

Console.WriteLine("Sum of odd elements: " + sumOfOdd);
Console.WriteLine("Sum of even elements: " + sumOfEven);

// <b>Резултат</b>:
// Sum of odd elements: 66
// Sum of even elements: 78
</pre>

    <p>Използваме оператор foreach, за да итерираме всеки елемент в масива. За всеки
      елемент проверяваме дали е четен или нечетен с помощта на оператора за модул
      (%). Ако числото е четно (делимо на 2), ние го добавяме към променливата sumOfEven.
      Ако е нечетно, го добавяме към променливата sumOfOdd. Накрая отпечатваме сумите
      на нечетните/odd/ и четните/even/ елементи.</p>
    <p><b>Забележка</b>: Този пример предполага, че масивът съдържа цели числа /int/,
      заради оператора %, който може да работи само с тях.</p>
    
    <p><b>Групиране на елементи на Масив</b></p>
    <p>Пример: В даден едномерен целочислен масив са кодирани цветовете на косите на 15 човека. 
      0-руса, 1-рижа, 2-кестенява, 3-черна. Да се напише програма, която определя броя хора във всяка група.</p>
      <p>Групиране на Масив :</p>
    
<pre class='pre'>
int[] hairColors = { 0, 1, 2, 0, 0, 1, 1, 3, 0, 0, 2, 3, 0, 1, 2 };

int[] colorCounts = {0, 0, 0, 0};

foreach (int color in hairColors)
{
    colorCounts[color]++;
}

Console.WriteLine($" Цвят - 0 - руса      : {colorCounts[0]} ");
Console.WriteLine($" Цвят - 1 - рижа      : {colorCounts[1]} ");
Console.WriteLine($" Цвят - 2 - кестенява : {colorCounts[2]} ");
Console.WriteLine($" Цвят - 3 - черна     : {colorCounts[3]} ");  


// Резултат:
// Цвят - 0 - руса      : 6 
// Цвят - 1 - рижа      : 4 
// Цвят - 2 - кестенява : 3 
// Цвят - 3 - черна     : 2
</pre>
    
    <p><b>Сортиране на Масив /bubble sort/</b></p>
    
<pre class='pre'>
int[] numbers = {21, 52, 12, 14, 45};

// Bubble sort algorithm
for (int l = 0; l &lt; numbers.Length - 1; ;++)
{
    for (int r = l + 1; r &lt; numbers.Length - 1; r++)
    {
        if (numbers[l] &gt; numbers[r])
        {
            // Swap elements
            int temp   = numbers[l];
            numbers[l] = numbers[r];
            numbers[r] = temp;
        }
    }
}

// Print the sorted array
foreach (int num in numbers)
{
    Console.Write(num + " ");
}

// <b>Резултат</b>: 12 14 21 45 52
</pre>
    
    <p>Алгоритъм за сортиране с мехурчета на масив във възходящ ред. Външният оператор
      for обхожда масива от първия елемент до последния елемент. Вътрешният for
      обхожда всички елементи в дясно от него. Ако даден елемент е по-голям от десния си,
      разменяте им местата, за да поставите по-големия елемент от дясно на левия. Процеса
      продължава, докато масивът бъде напълно сортиран /обходен от външния опреатор for/.</p>
    <p>Размяна на два елемента - I - ви начин</p>
    
<pre class='pre'>
int a = 5; b = 10; 

// swap:
int tmp = a;       // tmp == 5
a = b;             // a == 10
b = tmp;           // b == 5
</pre>
    
    <p>Размяна на два елемента - II - ри начин</p>

<pre class='pre'>
int a = 5; b = 10;

// swap:
a = a + b;    // a == 15
b = a - b;    // b == 5
a = a - b;    // a == 10
</pre>

    <p>Накрая се отпечатва сортирания масив с помощта на оператор foreach.</p>
    
    <p><b>Масиви от символни низове</b></p>
    <p>Масивите от символни низове обикновенно са едномерни, следния пример илюстрира
      сортиране на масив от символни низове, въведен от потребителя:</p>
      

<pre class='pre'>
Console.WriteLine("Enter the number of strings:");
int n = int.Parse(Console.ReadLine());

string[] strings = new string[n];
Console.WriteLine("Enter the strings:");

for (int i = 0; i &lt; n; i++)
{
    strings[i] = Console.ReadLine();
}

Array.Sort(strings); // Сортиране с метода Sort на масива

Console.WriteLine("Sorted strings:");
foreach (string str in strings)
{
    Console.WriteLine(str);
}
</pre>
    <p>В този пример програмата подканва потребителя да въведе броя низове,
        които иска да въведе. След това се създава масив от низове
        с посочения брой /<b>n</b>/. След това програмата иска от потребителя
        да въведе низовете един по един и ги съхранява в масива. Накрая
        сортира масива с помощта на <b>Array.Sort()</b> и отпечатва
        сортираните низове на екрана с помощта на оператор <b>foreach</b>.</p>
        
    <p><b>Сортиране на масив от символни низове по азбучен ред:</b></p>
    <p>Алгоритъма е същия като сортиране на едномерен масив, разликата
        е че се използва функция /string.Compare/, която сравнява два символни низа,
        и определя кой е по-голям, в зависимост, кой започва с буква
        от азбуката, която е по-напред: <b>string.Compare</b> връща
        целочислена стойност, която показва връзката между двата сравнявани
        низа. Ако низовете са равни, връща 0. Ако първият низ е по-малък
        от втория, връща отрицателно цяло число. Ако първият низ е
        по-голям от втория, той връща положително цяло число.</p>
            
<pre class='pre'>
string s1 = "<b>Hold</b>", s2 = "<b>Beer</b>";
int result = string.Compare(s1, s2);

if (result &lt; 0) // result е отрицатело число, защото 
{                  // s1 &lt; s2, т.е. Beer &gt; Hold
     // размяна на местата на 2-та 
     // елемента при сортиране по азбучен ред
     // защото Beer започва с <b>B</b>, което е преди <b>H</b>
}
</pre>
        
    <p><b>Двумрени и n-мерни</b></p>
    <p>В C#, двумерният масив е правоъгълна таблица от елементи с редове
        и колони. Декларира се с две измерения, като елементите могат
        да бъдат достъпни с помощта на два индекса.</p>
    <p>Ето пример за деклариране и инициализиране на двуизмерен масив в C#:</p>
    <p>int[,] matrix = new int[3, 4];</p>
    <p>В този пример сме декларирали двуизмерен масив с име matrix с 3
        реда и 4 колони. Елементите в масива са от тип int. Индексите
        на масива варират от 0 до дължината минус 1 във всяко измерение.</p>
    <p>Можете да получите достъп и да присвоите стойности на елементите
        на масива, като използвате индексите:</p>
    <p>matrix[0, 0] = 14;  // Задаваме стойност 14 на елемента на ред
        0, колона от 0 </p>
    <p>int value = matrix[1, 2];  // Четем стойността на елемента на ред
        1, колона 2</p>
    <p>Ето пример за инициализиране на двуизмерен масив със специфични
        стойности, използвайки синтаксиса на инициализатора на масива:</p>
            
<pre class='pre'>
int[,] matrix = {
    { 11, 12, 13, 14 },
    { 15, 16, 17, 18 },
    { 19, 20, 21, 22 }
};
</pre>

    <p>Можете също така да използвате итеративен оператор, за да обхождате елементите на двуизмерен масив:</p>

<pre class='pre'>
int[,] matrix = {
    { 11, 12, 13, 14 },
    { 15, 16, 17, 18 },
    { 19, 20, 21, 22 }
};

for (int row = 0; row &lt; matrix.GetLength(0); row++)  // GetLength(0) - Дължината по първото измерение == 3
{
    for (int col = 0; col &lt; matrix.GetLength(1); col++)  // GetLength(1) - Дължината по второто измерение == 4
    {
        int element = matrix[row, col];
        
        // Process the element
        Console.Write($" matrix[{row}][{col}]= {element} \t"); // спецификатор за табулация : /t
    }

    Console.WriteLine(); // нов ред

}

// Резултат:
// matrix[0][0]= 11        matrix[0][1]= 12        matrix[0][2]= 13        matrix[0][3]= 14 
// matrix[1][0]= 15        matrix[1][1]= 16        matrix[1][2]= 17        matrix[1][3]= 18 
// matrix[2][0]= 19        matrix[2][1]= 20        matrix[2][2]= 21        matrix[2][3]= 22 
</pre>

    <p>В този пример използваме метода GetLength, за да определим дължината
        на всяко измерение на масива.</p>
    <p>Важно е да се отбележи, че размерите на двумерен масив са фиксирани
        в момента на създаване и не могат да се променят в последствие
        /освен някои специфични случаи/ . Ако имате нужда от масив
        с динамичен размер или назъбен масив, можете вместо това да
        използвате списъци или назъбени масиви.</p>
    <p><b>Назъбени масиви</b></p>
    <p>Назъбен масив, наричан, е масив от еномерни масиви, където всеки
        под-масив може да има различна дължина от останалите. С други
        думи, това е масив от масиви, които не са непременно с еднакъв
        размер.</p>
    <p>За да създадете едномерен назъбен масив в C#, вие декларирате променлива
        на масив с квадратни скоби и я инициализирате с ключовата дума
        "new", последвана от размера на масива:</p>
    <p>int[][] jaggedArray = new int[3][];</p>
    <p>В този пример създаваме назъбен 2-мерен масив с три "реда",
        където всеки ред може да има различна дължина. Все още обаче
        не сме инициализирали всеки ред с определен брой елементи.</p>
    <p>За да инициализирате всеки ред от назъбения масив с определен брой
        елементи, можете да присвоите нов масив на всеки ред:</p>

<pre class='pre'>
jaggedArray[0] = new int[4];
jaggedArray[1] = new int[2];
jaggedArray[2] = new int[3];
</pre>

    <p>В този пример ние инициализираме първия ред с четири елемента,
        втория ред с два елемента и третия ред с три елемента.</p>
    <p>Можете също да инициализирате назъбения масив със стойности, като
        използвате вложени итеративни оператор:</p>


<pre class='pre'>
int[][] jaggedArray = new int[3][];

jaggedArray[0] = new int[] { 11, 12, 13, 14 };    // Тук се получава назъбване,
jaggedArray[1] = new int[] { 15, 16 };            // защото на всеки ред има
jaggedArray[2] = new int[] { 17, 18, 19 };        // различен брой елементи

for (int r = 0; r &lt; jaggedArray.Length; r++)
{
    for (int c = 0; c &lt; jaggedArray[r].Length; c++)
    {
        Console.Write($"jagged[{r}][{c}] = {jaggedArray[r][c]} \t ");
    }
    Console.WriteLine(); // нов ред
}

// Това ще изведе:
// jagged[0][0] = 11        jagged[0][1] = 12       jagged[0][2] = 13       jagged[0][3] = 14       
// jagged[1][0] = 15        jagged[1][1] = 16       
// jagged[2][0] = 17        jagged[2][1] = 18       jagged[2][2] = 19
</pre>


    <p><b>Символни масиви</b></p>
    <p>В C# можете да третирате низ като масив от знаци и да осъществявате достъп до отделните знаци по 
      техния индекс, точно както бихте направили с масив. </p>
      
<pre class='pre'>
string s = "Hold my beer";
int len   = s.Length;

for( int i = 0; i &lt; len; i++ )
{
    Console.Write($" s[{i}] => {<span class='grn'>s[i]</span>} ");
    Console.WriteLine(); // нов ред
}

// Result:
// s[0] => H
// s[1] => o
// s[2] => l
// s[3] => d
// s[4] =>  
// s[5] => m
// s[6] => y 
// s[7] =>  
// s[8] => b
// s[9] => e
// s[10] => e
// s[11] => r
</pre>
  
    <p>В този пример променливата <b>s</b> съдържа низа <b>"Hold my beer"</b>. Знаците в низа се достъпват с 
        помощта на индексиране като масив чрез променлива <b>i</b> в квадратни скоби (<span class='grn'>s[i]</span>).
       Достъпът до първия символ се осъществява чрез индекс 0, а индексът на последния е 11
    </p>        
        
    <p><b>Динамични масиви</b></p>
    <p>Ако имате нужда масивът да се разширява динамично, можете да използвате
        <b>List&lt;T&gt;</b> вместо традиционен масив. Класът <b>List&lt;T&gt;</b>
        предоставя динамична колекция с възможност за промяна на размера,
        която може да бъде разширявана или свивана според нуждите.
        Ето пример за използване на List&lt;T&gt; за постигане на динамично
        разширяване:</p>

<pre class='pre'>
<b>List&lt;int&gt; list = new List&lt;int&gt; { 21, 22, 23, 24, 25 };</b>
<b>list.Add(26);</b>
</pre>        

    <p>В този пример създаваме списък <b>List&lt;int&gt;,
    </b>тип <b>int</b> и го инициализираме със стойностите 21, 22, 23,
         24 и 25, използвайки синтаксиса на инициализатора на масив.
         След това методът <b>Add</b> се използва за динамично добавяне
         на нов елемент, 2<b>6</b>, в края на списъка. List&lt;T&gt;
         автоматично се справя с преоразмеряването на основния масив
         при добавяне на елементи. List&lt;T&gt; предоставя различни
         методи и свойства за работа с динамични списъци, като добавяне,
         премахване, вмъкване и други. Можете също така да получите
         достъп до елементи чрез техния индекс, като използвате нотацията
         в квадратни скоби (списък[индекс]). Имайте предвид, че List&lt;T&gt;
         осигурява динамично разширяване, но има леко натоварване на
         производителността в сравнение с традиционен масив. Ако имате
         нужда от най-ефективното използване на паметта и производителност
         на индексиране, масив с ръчно преоразмеряване може да е по-подходящ.</p>
    <p><b>Generic :</b>Типът <b>List&lt;string&gt; </b>се нарича <b>общ</b>
        /<b>generic</b>/ тип в C#. Това е клас, предоставен от <b>.NET</b>
        платформата, който представлява строго типизирана колекция
        от обекти. Ъгловите скоби <b><span class='red'>&lt;</span></b>string<b>
        <span class='red'>&gt;</span></b> показват, че списъкът е <b>списък</b> от <b>символни низове</b>.</p>
    <p><b>Списък</b>: Представлява обща колекция от данни от даден тип,
        която може да съхранява и манипулира множество обекти от дадения
        тип.</p>
    <p>&lt;<b><span class='red'>string</span></b>&gt;: Указва типа на
        обектите /символен низ - <b><span class='red'>string</span></b>/,
        които списъкът ще съдържа. Може да бъде <b>int</b>, <b>float</b>,
        <b>char</b> и др.</p>
    <p>Като използвате общия тип <b>List&lt;string&gt;</b>, вие декларирате
        променлива която може да съдържа колекция от низове. Методите
        на тази променлива могат да бъдат достъпени чрез нотация с
        точка (list<b><span class='red'>.</span>Add</b>, <b>list<span class='red'>.</span></b>Count
        и т.н.), за да извършвате операции в списъка, като добавяне
        или извличане на елементи.</p>
    <p><b>Enum</b></p>
    <p><b>Enum </b>(изброяване) в C# е тип стойност, който представлява
        набор от именувани константни стойности. Тя ви позволява да
        дефинирате колекция от свързани именувани константи, обикновено
        използвани за представяне на набор от възможни стойности за
        конкретно свойство или параметър. </p>
    <p>// Пример за <b>enum</b></p>
 
<pre class='pre'>
enum DaysOfWeek
{
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
}

class Program 
{    
    static void Main()
    {
        // Използване на <b>enum</b>
        DaysOfWeek today = DaysOfWeek.Friday;
        Console.WriteLine(today);  
    }
}

// <b>Резултат</b>: Friday
</pre>
    
    <p>В този пример изброяването (<b>enum</b>) <b>DaysOfWeek</b> представлява
        дните от седмицата, което ви позволява да присвоявате и работите
        с различните именувани константи.</p>
    <p><b>Структури</b></p>
    <p>Структурите в C# са типове стойности, които могат да съдържат членове
        - данни и методи. Те се използват за създаване на малки и леки
        обекти и обикновено се използват за малки сценарии, ориентирани
        към работа с данни. Те обикновено се използват за представяне
        на прости структури от данни, като координати / point.x, point.y
        /, дати настройки и др. За разлика от класовете, те не поддържат
        наследяване, и са много по-леки /по-оптимизирани/ от тях. </p>
    <p><b>Пример:</b></p>
        
<pre class='pre'>
// Декларация на структурата
struct <b><span class='red'>Student</span></b>
{
    public string <b><span class='blu'>name</span></b>;
    public int    <b><span class='lil'>age</span></b>;
    public double <b><span class='grn'>averageMark</span></b>;
}  

class Program 
{    
    static void Main()
    {
        // <b>Употреба:</b>
        <b><span class='red'>Student </span></b>student1     = new Student();
        student1.<b><span class='blu'>name</span></b>        = "John Doe";
        student1.<b><span class='lil'>age</span></b>         = 20;
        student1.<b><span class='grn'>averageMark</span></b> = 5.50;
                                                             
        <b><span class='red'>Student </span></b>student2     = new Student();        
        student2.<b><span class='blu'>name</span></b>        = "Jane Smith";
        student2.<b><span class='lil'>age</span></b>         = 21;
        student2.<b><span class='grn'>averageMark</span></b> = 5.75;
                
        // Ако направим: 
        student2 = student1;
        // То, данните от <b>student1</b> се <b><span class='red'>копират</span></b> върху данните на <b>student2</b> 
    }
}
</pre>

    <hr>
    <p><b>Задачи Масиви</b></p>
    <p> 1. Да се състави програма, при която от клавиатурата се въвеждат
        последователно 10 цели числа, а програмата ги извежда в ред
        обратен на реда на въвеждането им.</p>
    <p>2. Да се напише програма, която извежда средно аритметично от стойностите
        на елементите на даден едномерен масив с 15 елемента от тип
        int.</p>
    <p>3. Да се напише програма, която отпечатва индекса на първия четен
        елемент на даден едномерен масив с 10 целочислени елемента.
        Ако такъв елемент няма, да се отпечата -1</p>
    <p>4. Да се напише програма, която определя индексите на елементите
        на даден едномерен масив с 10 елемента тип int са равни на
        числото В - въведено от клавиатурата.</p>
    <p>5. В даден едномерен целочислен масив са кодирани цветовете на
        косите на 15 човека. 0-руса, 1-рижа, 2-кестенява, 3-черна.
        Да се напише програма, която определя броя хора във всяка група.</p>
    <p>6. Да се напише програма, която определя стойността и отпечатва
        най-големия отрицателен елемент на даден едномерен масив с
        15 целочислени елемента.</p>
    <p>7. Да се напише програма, която определя броя на всички отрицателни
        елементи на даден масив с 15 целочислени елемента.</p>
    <p>8. В даден масив елементите са подредени по големина. Да се напише
        програма, която проверява спазена ли е подредбата на елементите,
        и показва съответно съобщение (да/не). Масивът е с 15 елемента.</p>
    <p>9. Да се напише програма, която определя средно аритметичното на
        всички отрицателни числа в целочислен двумерен масив 5х3.</p>
    <p>10. Даден е двумерен масив 5х3 тип int. Да се напише програма,
        която изброява положителните, отрицателните и нулевите елементи
        в него.</p>
    <p>11. Да се напише програма, която копира елементите от един даден
        целочислен двумерен масив с 5x3 елемента в друг, също 5х3.</p>
    <p>12. Да се напише програма, която намира сумата на елементите, които
        са разположени на главния диагонал /от горно ляво към долно
        дясно/ на даден квадратен целочислен двумерен масив с 5х5 елемента.</p>
    <p>13. Създайте назъбен масив от цели числа с 3 реда. Всеки ред трябва
        да съдържа различен брой елементи (напр. {1, 2, 3}, {4, 5},
        {6}).</p>
    <p>14. Изчислете средното аритметично на всички елементи в назъбен
        масив и отпечатайте резултата.</p>
    <p>15. Намерете реда с най-голяма сума на елементите в назъбен масив
        и отпечатайте индекса на този ред.</p>
    <p>16. Сортирайте елементите във всеки ред от назъбения масив във
        възходящ ред</p>
    <p>17. Създайте назъбен масив от низове и го попълнете с някои стойности.
        Отпечатайте всички низове в масива, които започват с буквата
        'A'; </p>
    <p><b>Hint</b>: Използвайте метода <b>StartsWith</b>, на обекта <b>string</b>: </p>
<pre class='pre'>
string str = "Hold my beer";

if (str.<b>StartsWith</b>('H'))
{
    Console.WriteLine("String starts with 'H'");
}
</pre>
        
    <p>18. Намерете реда с най-много елементи в назъбен масив и отпечатайте индекса на този ред.</p>
        
    <p><b>Задачи символни низове</b></p>
    <p>1. Пребройте срещанията на въведен символ въ въведен низ.</p>
    <p>2. Обърнете низ напишете програма, която приема низ като вход и връща обърнат
      от зад напред същия низ.</p>
    <p>3. Въведен низ съдържа няколко кръгли скоби. Да се напише програма, която установява
      правилно ли са затворени скобите.</p>
    <p>4<b>.</b> Напишете програма, която приема низ и проверява дали е палиндром /ако
      се чете от зад напред = ако се чете отпред назад/ 1001; abccba, abc0cba .../</p>
    <p>5. Да се напише програма, в която се въвежда знаков низ и като резултат програмата
      отпечатва онези малки латински букви, които не се съдържат в низа.</p>
    <p>6. Да се напише програма, която в даден низ удвоява всеки символ.</p>
    
    <hr>
    
    <h2 id='V'>V. Основи на ООП</h2>
    <p><b>Обектно-ориентираното програмиране </b>(ООП) е принцип за структуриране
        на програми, който организира кода в <b>обекти</b>, които са
        екземпляри на <b>класове</b>. Фокусира се върху идеите
        за капсулиране, наследяване и полиморфизъм за създаване на
        модулен, многократно използваем и лесен за поддръжка и надграждане
        код. OOP насърчава организиране на кода в самостоятелни и слабо
        свързани /самостоятелни и независещи един от друг/ обекти.
        </p>
    <p>Клас се дефинира, като използвате ключовата дума <b>class</b>,
        последвана от името на класа. След като сте дефинирали клас,
        можете да създадете екземпляри (обекти) на този клас, като
        използвате ключовата дума <b>new</b>. Създаването на обект
        ви позволява да създавате множество екземпляри на класа, всеки
        със собствен набор от данни и поведение. Поведението на даден
        обект се определя от <b>методите /функциите/ </b>на класа.
        Те съдържат действията или операциите, които даден обект може
        да извърши. </p>
    <p><b>Класове, обекти и методи. </b></p>
    <p>Класовете се състоят от полета /променливи/, методи /функции/,
        </p>
    <p><b>Класове</b>: Класът е план за създаване на обекти. Той дефинира
        свойствата /променливите/, методите /функциите/ и събитията,
        които даден обект може да има.</p>
    <p><b>Обекти</b>: Обектът е екземпляр на клас. Той има всички свойства,
        методи и събития, дефинирани в класа.</p>
    <p><b>Полета /fields/</b> : Полетата са атрибутите на даден обект. Те определят
        състоянието на даден обект и могат да бъдат прочетени или модифицирани.
        Обикновенно представляват промеливи /или член-променливи/;</p>
    <p><b>Свойства</b> - полета /променливи/, които имат специални <b>Get</b>/<b>Set</b>методи,
        които променят техните стойности /с цел валидация на данните,
        примерно оценка на студента не може да е 8.00 ➜ не може оценката
        да е под 2.00 или над 6.00/.</p>
    <p><b>Методи</b>: Методите са действията, които даден обект може да
        извърши. Те определят поведението на даден обект и могат да
        приемат параметри и да връщат стойности. /Представляват функции/</p>
    <p><b>Конструктори</b>: Конструкторите са специални <b>методи </b>/функции/,
        които се извикват при създаване на обект. Те служат за да инициализират
        свойствата /променливите/ на обекта, и да извършат някаква
        предварителна работа, ако е необходимо, при създаването на
        обекта. Винаги името на конструктора с същото като името на
        класа.</p>
            
<pre class='pre'>
public class <b><span class='blu'>MyClass </span></b>// името на класа <b>винаги</b> съвпада с името на конструктора
{
     private int myNumber;       // член - променлива
     public <b><span class='blu'>MyClass</span></b>(int number)  // конструктор, вика се при създаване на 
     {                           // обект от този клас с ключова дума <b>new</b>
          myNumber = number;     // инициализация на член променлива от 
                                 // конструктора
                                 
          Console.WriteLine("MyClass - Constructor: " + number); 
     }
     
     public void MyMethod(string s)
     {
        Console.WriteLine("MyMethod: " + s);
     }

     
     // .......
}

// ....

class Program 
{    
    static void Main()
    {
         // създаване на обект от <b><span class='blu'>MyClass</span></b> 
         <b>MyClass</b> myObject = <b>new</b> <b><span class='blu'>MyClass</span></b>(<b>42</b>); // тук се вика конструктора с параметър <b>42</b>
         
         myObject.MyMethod("Hold my beer"); // викаме метода MyMethod на обекта myObject
    }
}    


// Резултат:
// MyClass - Constructor: 42
// MyMethod: Hold my beer 
</pre>            
            
    <p><b>Обект за еднократна употреба</b>: Инструкцията <b>using</b> в C# се използва,
        за да се гарантира, че обектът за еднократна употреба е правилно
        освободен, когато вече не е необходим. Той предоставя удобен
        начин за автоматично почистване на ресурси и освобождаването
        им обратно в системата. </p>
            
<pre class='pre'>
<b>using </b> (StreamReader <b>reader</b> = <b>new</b> StreamReader("<b>Program.cs</b>"))
{
    string s =  reader.ReadToEnd();
    Console.WriteLine(s);
}   // обекта за еднократна употреба reader се освобождава след '}'


// Резултат /Съдържанието на файла Program.cs/ :
 
// using (StreamReader reader = new StreamReader("Program.cs"))
// {
//     string s =  reader.ReadToEnd();
//     Console.WriteLine(s);
// }   // обекта за еднократна употреба reader се освобождава след '}'
</pre>
   
    <p>В рамките на блок <b>using</b> можете да извършвате операции върху
        обекта <b>reader</b>. В този случай се извиква <b>reader.ReadToEnd()</b>,
        за да се прочете съдържанието на файла <b>Program.cs</b> в низа <b>s</b>. 
        След като изпълнението на кода достигне края на блока <b>using</b>, 
        автоматично се извиква методът <b>Dispose()</b> на обекта <b>reader</b>. 
        Това гарантира, че всички ресурси, заети от обекта <b>reader</b>, са правилно
        освободени, като например затваряне на мрежови връзки или освобождаване
        на памет.</p>
        
    <p><b>Finalizers</b>: Деструктори, обикновенно не са необходими, тъй
        като c# има garbage collectors, които се грижат паметта заета
        от обекта да се освободи, в случай че обектите вече не са необходими
        в дадена програма. Този <b>метод </b>се извиква автоматично
        от <b>garbage collector</b>-a когато тръгне да освобождава
        паметта, заета от обекта. Винаги името на финализатора с същото
        като името на класа, но започва със знака <b><span class='red'>~ </span></b>:</p>

<pre class='pre'>
<b><span class='red'>~</span></b><b>ClassName</b>()
{
    // Finalizer code goes here.
}
</pre>

    <p><b>Индексатор</b> - /indexer/ е механизъм /<b>Get/Set</b> методи/,
        който позволява достъп до обекти в масив чрез синтаксис за
        индексиране. Той предоставя възможност за <b>Get</b>/<b>Set</b>
        методи. Индексаторите позволяват и <b>низови</b> индекси, като:
        days['index1'], days['index2'] /ако <b>days </b>е индексиран
        масив/. Можете да укажете поведението за извличане или задаване
        на стойности въз основа на предоставения индекс чрез <b>Get/Set</b>
        методите, което може да направи достъпа и манипулирането на
        данни във вашия клас по-удобен.</p>
    <p>Класът MyCollection демонстрира използването на <b>индексатор</b>,
        който позволява да осъществявате достъп до елементи в масива
        от данни, като използвате синтаксис за индексиране.</p>

<pre class='pre'>
// Пример за клас с <b>индексатор</b>
class MyCollection
{
    private string[] <b><span class='blu'>data </span></b>= new string[5]; // Масив тип низ, върху който 
                                           // ще създадем <b>индексатор</b>
    public string this[<b><span class='grn'>int</span></b><span class='grn'> </span>index] // декларация на <b>индексатор </b>тип <b><span class='grn'>int </span></b>на масива <b><span class='blu'>data</span></b>
    {
         get { return <b><span class='blu'>data</span></b>[index]; }
         set { <b><span class='blu'>data</span></b>[index] = value;}
    }
}


class Program 
{    
    static void Main()
    {
        // Използване на <b>индексатор: </b>създаване на <b>indexer </b>обект - <b><span class='red'>collection</span></b>
        // Използване на <b>индексатор: </b>създаване на <b>indexer </b>обект - <b><span class='red'>collection</span></b>
        // от клас <b>MyCollection</b>
        MyCollection <b><span class='red'>collection </span></b>= new MyCollection();
        
        // използване на <b>Set</b> метода на <b>индексатора</b>
        collection[0] = "<span class='ora'>Hold my</span>"; 
        collection[1] = "<span class='ora'>beer</span>"; 
        
        // използване на <b>Get</b> метода на <b>индексатора </b>
        Console.WriteLine(collection[0]);  // Резултат: <span class='ora'>Hold my</span>
        Console.WriteLine(collection[1]);  // Резултат: <span class='ora'>beer</span>
    }
}   
</pre>

    <p><b>Модификатор на методите</b></p>
    <p><b>Статични / не-статични методи</b>: Статичните методи са методи, които принадлежат
        на клас, а не на екземпляр на класа. Те могат да бъдат извикани
        без създаване на обект от класа.</p>
    <p>Статичните методи са полезни, когато трябва да се извърши действие,
        което не е специфично за даден на клас. Например, статичен
        метод може да се използва за извършване на изчисление или за
        извличане на стойност, която не зависи от състоянието на даден
        обект и не е свързана с него. За да декларирате статичен метод,
        използвате ключовата дума <b>static </b>в сигнатурата на метода.
        Например:</p>
            
<pre class='pre'>
public class Calculator
{
    public static int AplusB(int a, int b)
    {
        return a + b;
    }
}

class Program 
{    
    static void Main()
    {
        // Не е необходимо да се създава обект, извиква се по следния начин:
        int result = Calculator.AplusB(10, 20); // стойността на result след този ред е 30
        Console.WriteLine("10 + 20 = " + result);
    }
}   

// Резултат:
// 10 + 20 = 30
</pre>

    <p>Уместно е да използвате статични методи или променливи, когато
        искате да извършите обща операция, която не разчита на състоянието
        на конкретен екземпляр на обект, или когато искате да споделите
        стойност измежду всички обекти от даден на клас /1 общо поле
        - променлива, еднаква за всички обекти от дадения клас/. Освен
        това статичните променливи могат да създадат проблеми с паралелността
        /многозадачност - едновременно изпълнение/, ако множество нишки
        се опитат да осъществят достъп до тях или да ги променят едновременно.
        В резултат на това обикновено е добра идея да се ограничи използването
        на статични методи и променливи.</p>
    <p><b>Как се създава обект и се извиква негов метод</b>? </p>
    <p>Да добавим нестатичен метод /по подразбиране всички методи и полета
        са такива, ако не е указано, че са статични/ към даден клас - <b>void MyMethod()</b> :</p>
            
<pre class='pre'>
namespace HoldMyBeer // namespace служи за групиране на класове изпълняващи 
                     // подобни /общи/ задачи
{
    class MyClass // клас MyClass
    {
        public void <b>MyMethod</b>() // Метод - функция, дефинирана от потребителя, не-статична
        {
            Console.WriteLine(" ------ MyMethod called ! ------ ");
        }
    }        
        
    class Program 
    {    
        static void <b>Main</b>(string[] args)
        {
            <b>MyClass p = new MyClass(); // <span class='red'>new</span> - </b>създаване на обект <b>p</b> от класа 
                                       // <b>MyClass</b> в променливата <b>p</b>
            <b>p</b>.MyMethod(); // Извикване на MyMethod

            // след работа с обект не е необходимо той да се освобождава;    
            // за това се грижи т.нар. Garbage Collector
        }
    }
}
</pre>

    <p>Тъй като функцията <b>Main </b>е static, тя се извиква от средата,
        без да е необходимо да се създаде обекта Program, но за да
        извикаме функцията MyMethod трябва да създадем обект от класа
        Program. Ако MyMethod беше <b>static</b>,  щяхме да можем да
        го извикаме като: MyMethod();</p>
    <p><b>Подаване на параметри на функцията Main</b></p>
    <p>От командния ред, при стартирането на програмата, могат да се подадат
        параметри на функцията <b>Main. </b>Това става по следния начин:</p>

<pre class='pre'>
using System;

class Program
{
    static void Main(<b>string[] args</b>)
    {
        if (args.Length &gt;= 2) 
        {
            string inputString = args[0];
            int inputNumber = Convert.ToInt32(args[1]);
            Console.WriteLine("Input String: " + inputString);
            Console.WriteLine("Input Number: " + inputNumber);
        }
        else
        {
            Console.WriteLine("Please provide both a string and an integer parameter.");
        }
    }
}
</pre>

    <p>За да предадете низ и целочислен параметър, когато стартирате програмата
        от командния ред, трябва да въведете :</p>
    <p><b>dotnet run "Hold my beer" 42</b></p>
    <p><b>Резултат:</b></p>
    <p>Input String: Hold my beer</p>
    <p>Input Number: 42</p>
    <p>В този пример методът <b>Main</b> има параметър args, който е масив
        от аргументи на командния ред, предадени на програмата. Проверяваме
        дали има поне два аргумента <b>(args.Length &gt;= 2)</b> и
        след това извличаме първия аргумент като низ (<b>args[0]</b>)
        и втория аргумент като цяло число /<b>int</b>/ с помощта на
        <b>Convert. ToInt32(args[1])</b>. След това показваме na екрана
        подадения като параметър низ и число с помощта на Console.WriteLine.</p>
    <p>
    
    <b>Подаване на параметри на методи /ref, return ref/ :</b></p>

<pre class='pre'>
static void AddOne(<b>ref </b>int x) // <b>ref </b>- променя стойността на подадената променлива
{
    x += 1;
}

static void AddTwo(int x) // без <b>ref </b>- стойността на подаденната променлива не се 
                          //променя
{
    x += 2;
}

int num = 5; 
AddOne(<b>ref</b> num);
Console.WriteLine(num); // Извежда: 6; num се е променило от <b>AddOne</b>

AddTwo(num);
Console.WriteLine(num); // Извежда: 6; num не се е променило от <b>AddTwo</b>
</pre>

    <p>Възможно е <b>ref</b> да се използва при връщане на резултат от метод: </p>
      <p>return <b>ref</b> number;</p>
      <p>но се препоръчва да се избягва, тъй като води до объркващ код.</p>
      <p><b>in/out
    </b> параметри на функция</p>
    <p>В C# параметрите на функциите могат да бъдат дефинирани като <b>in</b> или <b>out</b>.</p>
    <p><b>in</b> параметрите се използват за предаване на стойности към
        функция чрез препратка /референция, ref/, без да се позволява
        промяна. Използва се за входни стойности, които не трябва да
        се променят във функцията.</p>
    <p><b>out</b> параметрите се използват за връщане на стойности по
        референция и позволяват на функцията да ги променя. Те обикновено
        се използват, когато една функция трябва да върне множество
        стойности. Извикващият код трябва изрично да подаде променлива
        на <b>out</b> параметър, преди да извика функцията.</p>
    <p><b>Пример:</b></p>

<pre class='pre'>
static void AddAndMultiply(int a, int b, out int sum, out int product)
{
    sum = a + b;
    product = a * b;
}

// Можете да използвате тази функция, както следва:

int num1 = 5;
int num2 = 3;
int resultSum, resultProduct;
AddAndMultiply(num1, num2, out resultSum, out resultProduct);

Console.WriteLine($"Sum: {resultSum}");
Console.WriteLine($"Product: {resultProduct}");

<b>// Резултат:</b>
// Sum: 8
// Product: 15
</pre>

    <p>В този пример функцията AddAndMultiply приема <b>a</b> и <b>b</b> като <b>in</b> параметри и присвоява <b>сумата</b> и 
    <b>произведението</b> от <b>a</b> и <b>b</b> съответно на изходните параметри <b>resultSum</b> и <b>resultProduct</b>.</p>
    
    <p><b>Getters / Setters</b></p>
    <p><b>Getters </b> и <b>setters </b>се използват за контролиране на достъпа до
        полета или свойства на клас. Те предоставят начин за четене,
        писане или манипулиране на данните, съхранени в тези полета
        или свойства. <b>Getters </b>ви позволяват да извлечете стойността
        на поле или свойство, докато <b>setters </b>ви позволяват да
        променяте или актуализирате тази стойност. Освен това <b>Getters </b>и
        <b>setters</b>могат да позволят да се добави логика или да се валидират 
        данните, когато се осъществява достъп до данни или се модифицират, което
        може да помогне за предотвратяване на грешен формат на данните
        - примерно ако трябва стойността да е число по-голямо от 0.</p>
    <p>Примера по-долу показва как комбинация от <b>Методи</b> и <b>полета </b>се
        използва за построяването на клас Student, който има Име на
        студент /name/ и възраст /age/:</p>
            
<pre class='pre'>
class Student { // клас Student  
    // полета
    private string name; // private поле за името на студента
    private int age;     // private поле за възрастта на студента
    
    public int publicAge = 0; // public поле за тест на достъпа
    
    // Constructors
    public Student() { // constructor, който установява 
                       // стойности по подразбиране на полетата
        name = "Unknown";
        age = 0;
    }

    public Student(string name, int age) { // Конструктор, който приема name /име/ и  
                                           // age /възраст/ като аргументи /параметри/
        <b>this</b>.name = name; // Използваме ключова дума "<b>this</b>" за да се обърнем 
                          // към полето name на текущия обект
        <b>this</b>.age = age;   // Използваме ключова дума "<b>this</b>" за да се обърнем   
                          // към полето age на текущия обект
    }

    // <b>Properties - свойства</b>
    public string Name {         // свойство /property/ за достъп до полето <b>Name - </b>Име
        get { return name;  }    // Getter метод, който втъща стойността на 
                                 // полето name /име/
        set { name = value; }    // Setter метод за установяване на 
                                 //  стойносттта на полето  name /име/
    }

    public int Age { // public - свойство /property/ за достъп до полето <b>age - </b>възраст
        get { return age; }   // Getter -метод, който връща стойността на 
                              // полето age /възраст/
        set {   // Setter -метод за установяване на
                // стойносттта на полето age /възраст/ 
                if (value >= 18 ) age = value; 
                else Console.WriteLine("Невалидна възраст:" + value); 
            } 
    }
    
    // <b>Методи</b>
    public void PrintInfo() { // public метод, който извежда на екрана 
                              // име и възраст на студента
        Console.WriteLine("Name: " + name);
        Console.WriteLine("Age: " + age);
    }
}


public class Program
{
    public static void Main()
    {
    
        // Горния <b>клас Student </b>се използва по следния начин:
        // създаване на нов обект <b>Student</b>, име - "John Doe", години: 21; Можем 
        // да зададем невалидна стойност за възраст, например 13 в конструктора
        // тъй като той не използва <b>setter </b>за установяване на стойност.

        // <span class='red'>оператор <b>new</b></span> - създава 
        // нов обект от клас Student в променливата myStudent
        Student myStudent = <b><span class='red'>new </span></b>Student("John Doe", 21); 
        
        // Изикваме метод за да получим пълното име на студента 
        string fullName = myStudent.<b>Name</b>;
        
        // извеждане на екрана в терминала на пълното име на студента
        Console.WriteLine(<b>fullName</b>);
        
        // Установяване на възрастта на нова невалидна стойност (13) чрез <b>setter;</b>
        <b>// setter </b> печата съобщение за невалидни данни, и не установява стойността
        myStudent.<b>Age</b> = 13;
        
        
        // опит за такъв директен достъп дава грешка при 
        // компилация, трябва да се работи през getter/setter:
        // myStudent.age = 13;
        
        // достъп до public поле, директна работа, без getter/setter:
        myStudent.publicAge = 21;
        
        
        // извеждане на екрана на обновената възраст
        Console.WriteLine($"The student's age is now {myStudent.<b>Age</b>}.");
        
        // Установяване на възрастта на нова стойност чрез <b>setter</b>
        myStudent.<b>Age</b> = 22;
        
        // извеждане на екрана на обновената възраст
        Console.WriteLine($"The student's age is now {myStudent.<b>Age</b>}.");

    }
}


// Резултат:
// John Doe
// Невалидна възраст:13
// The student's age is now 21.
// The student's age is now 22.
</pre>        
        
    <hr>
    <p><b>Задачи ООП</b></p>
    <p>1. Създайте клас с име „Студент“ със свойства като „Име“, „Възраст“
        и „Оценка“. Напишете методи за задаване и получаване на тези
        свойства. /<b>решението е по-долу</b>/</p>
    <p>2. Добавете проверка /валидация/ на setter-а на оценка на горната
        задача, който да проверява дали оценката е в интервала [2 -
        6], и ако не е да не я променя, а да извежда съобщение;</p>
    <p>3. Създайте клас с име „Човек“ със свойства като „Име“ - string,
        „Възраст“ - int и „Град“ - string. Напишете методи за set и
        get на тези свойства.</p>
    <p>4. Създайте клас с име "Правоъгълник" със свойства като
        "Ширина" - float и "Височина" - float.
        Напишете методи за изчисляване на неговата площ и периметър
        - face / perim.</p>
    <p>5. Създайте клас с име „BankAccount“ със свойства като „AccountNumber“
        - string и „Balance“ - int. Напишете методи за депозиране /deposit/
        и теглене на пари /withdraw/ от сметката.</p>
    <p>6. Създайте клас с име „Служител“ със свойства като „Име“, „Заплата“
        и „Длъжност“. Напишете методи за задаване и получаване на тези
        свойства.</p>
    <p>7. Създайте клас с име „Кръг“ със свойства като „Радиус“. Напишете
        методи за изчисляване на неговата площ - face, и обиколка -
        circle.</p>
    <p>8. Създайте клас с име „Книга“ със свойства като „Заглавие“, „Автор“
        и „Издател“. Напишете методи за задаване и получаване на тези
        свойства.</p>
        
    <p><b>Примерно решение на задача 1 :</b></p>
        
<pre class='pre'>
class Student
{
    private string name = "";
    private int age;
    private double grade;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
    public int Age
    {
        get { return age; }
        set { age = value; }
    }
    public double Grade
    {
        get { return grade; }
        set { grade = value; }
    }
    public void PrintDetails()
    {
        Console.WriteLine("Name: " + name);
        Console.WriteLine("Age: " + age);
        Console.WriteLine("Grade: " + grade);
    }
}

class Program
{
    static void Main(string[] args)
    {
        Student student = new Student();
        student.Name = "John";
        student.Age = 20;
        student.Grade = 4.75;
        student.PrintDetails();
    }
}
</pre>

    <hr>
    <h2 id='VI'>VI. ООП - Тънкости</h2>
    <p><b>Тънкости на обектно-ориентирано програмиране.</b> </p>
    <p>Това са правила, които са полезни и широко използвани в Обектно-ориентираната
        разработка на софтуер. </p>
    <p><b>Капсулация</b>: Капсулацията помага при организирането и структурирането
        на кода чрез групиране на свързани данни и поведение в обекти.
        Този принцип осигурява скриване на данни, позволявайки вътрешните
        детайли на даден обект да бъдат скрити. Това насърчава модулността
        на кода, повторната употреба и поддръжката.</p>
    <p><b>Наследяване</b>: Наследяването ви позволява да създавате нови
        класове въз основа на съществуващи, наследявайки техните атрибути,
        методи и поведение. Този принцип насърчава повторното използване
        на кода и разширяемостта, тъй като можете да дефинирате обща
        функционалност в базов клас и да наследите специализирани класове
        от него. Наследяването помага при създаването на йерархична
        структура, изразявайки връзки между класовете.</p>
    <p><b>Полиморфизъм</b>: Полиморфизмът позволява обекти от различни
        типове да бъдат третирани еднакво чрез общ интерфейс. Той позволява
        кодът да бъде написан по общ начин, третирайки различни обекти
        по еднакъв начин, което стандартизира работата с тях. </p>
    <p><b>Абстракция</b>: Абстракцията ви позволява да се съсредоточите
        върху основните характеристики и поведение, като същевременно
        скривате неуместните подробности. Помага при създаването на
        опростени и повторно използвани модели на сложни системи. Абстракцията
        поддържа скриването на информация, намалява сложността и подобрява
        разбираемостта на кода.</p>
    <p><b>Модулност и поддръжка</b>: Обектно-ориентираното програмиране
        насърчава модулния дизайн, където кодът е организиран в самостоятелни
        модули (класове/или Namespaces). Това подобрява организацията
        на кода, намалява зависимостите и улеснява поддържането и подобряването
        на кодовата база с течение на времето.</p>
    <p><b>Наследяване</b></p>
    <p>Наследяването е идея в обектно-ориентираното програмиране,
        която позволява на даден клас да наследява свойства и поведение
        от друг клас. </p>
    <p>Наследяването се постига чрез създаване на нов клас, наречен <b>производен</b>
        клас /или подклас/, от съществуващ клас, наречен <b>базов</b>
        клас /или суперклас/. Произведеният клас наследява всички членове
        (полета, свойства, методи) на основния клас, което ви позволява
        да ги използвате повторно и да разширите функционалността базовия
        клас като добавяте нови полета, свойства, методи.</p>
    <p>Наследяването насърчава <b>повторното използване на кода</b>, като ви 
        позволява да дефинирате общи атрибути
        и поведения в базов клас и да ги използвате повторно в няколко
        различни производни класа. Това елиминира необходимостта от
        дублиране на код, което води до по-чист и по лесен за поддържка
        код.</p>
    <p>Наследяването позволява създаването на <b>йерархия</b> на класовете,
        където класовете са организирани в йерархична структура въз
        основа на техните връзки. Производните класове могат да специализират
        и разширят поведението на базовия клас чрез добавяне на нови
        членове или замяна на съществуващи.</p>
    <p>Наследяването поддържа следните <b>връзки</b>:</p>
    <p>•"class X <b>is-a</b> class Y" - Тази фраза /<b>
        is-a - превежда се като "е"</b>/
        предполага пряка връзка на наследяване, където клас <b>X</b>
        е специфичен вид клас <b>Y</b>. Това означава, че клас <b>X</b>
        се наследява от клас <b>Y</b> и споделя неговите свойства,
        методи и поведение. тази връзка се основава на <b>специализация</b>,
        което показва, че клас <b>X</b> е специализирана версия или
        подтип на клас <b>Y</b>. Например, ако имаме клас, наречен
        Animal, и клас, наречен Dog, можем да кажем, че "Dog
        <b>is-a </b>Animal" /Кучето <b>е</b> Животно/.</p>
    <p>•"class X <b>is-a-kind-of</b> class Y" - Тази фраза /<b>
        is-a-kind-of - превежда се като "е от вида на"</b>
        / предполага по-обща връзка, при която клас <b>X</b> принадлежи към 
        по-широка категория или вид, представен от клас
        <b>Y</b>. Той показва, че клас <b>X</b> е един от няколко различни
        вида, които попадат в категорията, представена от клас <b>Y</b>.
        "<b>е-вид-на"</b> връзката се основава на <b>категоризация</b>
        или <b>класификация</b>. Например, ако имаме клас, наречен
        Vehicle, и класове като Car, Bike и Bus, можем да кажем, че
        "Car, Bike и Bus <b>is-a-kind-of</b> Vehicle" /Кола,
        Колело и Автобус <b>са-от-вида-на</b> Превозно средство".</p>
    <p>В обобщение, Връзката „class X <b>is-a</b> class Y" означава
        пряка връзка на наследяване, където клас <b>X</b> е специализирана
        версия на клас <b>Y</b>. Връзката "class X <b>is-a-kind-of</b>
        class Y" показва, че клас <b>X</b> принадлежи към по-широка
        категория, представена от клас <b>Y</b>. </p>
    <p>Наследяването играе ключова роля в постигането на <b>полиморфизъм</b>,
        което е способността на обекти от различни типове да бъдат
        третирани като обекти от общ базов тип. Полиморфизмът ви позволява
        да пишете код, който може да работи с обекти от различни производни
        класове чрез общ интерфейс /набор от функции, методи, полета,
        свойства /, осигурявайки гъвкавост и разширяемост.</p>
    <p>Наследяването позволява на производните класове да <b>предефинират</b>
        /заменят/ методите и свойствата на базовия клас. Освен това,
        производните класове могат да имат достъп до членове на базовия
        клас /които не са <b>private</b>/, което им позволява да използват
        повторно и да разширят поведението, дефинирано в базовия клас.</p>
    <p>В обобщение, наследяването осигурява начин за установяване на връзки
        между класове, насърчава повторната употреба на код. Тя ви
        позволява да създавате йерархии на класове, да специализирате
        поведение и да изграждате по-гъвкави и модулни приложения.</p>
    <p><b>Наследяване на класове</b></p>
    <p>За да създадете производен клас в C#, използвате символа двоеточие
        (:) след името на производния клас, последвано от името на
        основния клас. Това установява връзката на наследяване между
        двата класа. След това производният клас може да разшири или
        модифицира функционалността на базовия клас чрез добавяне на
        нови членове или замесдтване на съществуващи. В C# даден клас
        може да наследи само един базов клас.</p>
    <p><b>Пример</b>:</p>
        
<pre class='pre'>
// Базов клас
class <b><span class='lil'>Vehicle</span></b>
{
     public string <b><span class='blu'>Brand </span></b>{ get; set; } = "";
 
     public void <b><span class='blu'>Start</span></b>() // Метод
     {
         Console.WriteLine("Vehicle Class: Vehicle started.");
     }
     
     public void <b><span class='blu'>CheckFuel(int liters)</span></b>
     {
         Console.WriteLine($"Vehicle Class: Fuel Checked. Fuel ({liters}) ltr. ");
     }
 
     public <b>virtual </b>void <b><span class='blu'>Stop</span></b>() // <b>virtual </b>метод, може да бъде презаписан с <b>override</b>
     {                          // в наследяващия клас 
         Console.WriteLine("Vehicle Class: Vehicle stopped.");
     }
}

// Наследяване на базов клас <b>Vehicle</b> от класа <b>Car</b>;
    
// Car - клас производен на класа <b>Vehicle</b> /под-клас/

class <b><span class='ora'>Car </span></b><span class='red'>:</span> <b><span class='lil'>Vehicle</span></b>
{
     public void <b><span class='grn'>CheckFuel</span></b>() // добавяне на метод със същото име в класа Vehicle,
     {                        // но с различна сигнатура /без параметър int liters/
         Console.WriteLine("Car Class    : Fuel Checked.");
     }
     
     public void <b><span class='grn'>Accelerate</span></b>() // добавяне на нов метод в класа Vehicle
     {
         <b>this</b>.<b><span class='grn'>CheckFuel</span></b>();    // с <b>this </b>се извиква метода 
                              // <b><span class='grn'>CheckFuel </span></b>на класа <b><span class='ora'>Car</span></b>
                              
         <b><span class='blu'>CheckFuel(50);</span></b> // Полиморфизъм: автоматично се извиква метода
                        // който <b>има</b> парамтър int в сигнатурата, т.е. Vehicle.CheckFuel
                        // /Compile time Polymorphysm/                        

         <b><span class='grn'>CheckFuel();</span></b>   // автоматично се извиква метода
                        // който <b>няма</b> парамтър int в сигнатурата, т.е. Car.CheckFuel
                              
         Console.WriteLine("Car Class    : Car accelerating.");
     }
     
     public <b>override</b> void <b><span class='grn'>Stop</span></b>() // <b>override - </b>предефиниране /заместване/ 
                                 // на метода <b>virtual</b> <b><span class='blu'>Stop </span></b>от класа Vehicle 
     {
         Console.WriteLine("Car Class    : Car now stopped.");
         <b>base.<span class='blu'>Stop</span>();  </b>// ключова дума <b>base</b> извиква оригиналния метод <b><span class='blu'>Stop </span></b>
                       // на базовия клас <b>Vehicle</b> 
     }
}     

public class Program
{
    public static void Main()
    {

        // <b>Използване</b>
        
        <b><span class='ora'>Car </span></b>myCar = new <b><span class='ora'>Car</span></b>(); // myCar - обект от клас Car
        
        myCar.<b><span class='blu'>Brand</span></b>= "Toyota"; // <b><span class='blu'>Brand </span></b>-свойство, наследено от класа <b><span class='lil'>Vehicle</span></b>
        
        myCar.<b><span class='blu'>Start</span></b>();         // <b><span class='blu'>Start </span></b>- метод, наследен от класа <b><span class='lil'>Vehicle</span></b>
        
        myCar.<b><span class='grn'>Accelerate</span></b>();    // нов Метод, дефиниран в класа <b>Car</b>
        
        myCar.<b><span class='grn'>Stop</span></b>(); // предефиниран метод на базовия клас;
                      // ще бъде извикан метода <b><span class='grn'>Stop</span> </b>на класа <b><span class='ora'>Car</span></b>
                      // /Run-time Polymorphysm/
    }
}

// Резултат:
// Vehicle Class: Vehicle started.
// Car Class    : Fuel Checked.
// Vehicle Class: Fuel Checked. Fuel (50) ltr. 
// Car Class    : Fuel Checked.
// Car Class    : Car accelerating.
// Car Class    : Car now stopped.
// Vehicle Class: Vehicle stopped.
</pre>

    <p>В този пример класът "<b>Car</b>" наследява базовия клас
        "<b>Vehicle</b>". В резултат на това класът <b>Car</b>            
        автоматично получава достъп до свойството <b>Brand</b> /Марка/
        и метода <b>Start</b>, дефинирани в базовия клас <b>Vehicle</b>.
        Освен това класът <b>Car</b> въвежда свой собствен метод, наречен
        <b>Accelerate</b> /Ускоряване/.</p>
    <p>За да замените метод в C#, използвате ключовата дума <b>override</b>            
    в производния клас. Методът в производния клас трябва да има
        същото <b>име</b>, <b>тип </b>и <b>параметри </b>като метода
        в основния клас, и да е маркиран с <b>virtual</b>. Замяната
        на метод ви позволява да приспособите поведението на метод
        в базовия клас към нуждите на производния клас, като същевременно
        използвате общ интерфейс, дефиниран в базовия клас. Ако имате
        обект от базовия клас, с предефиниран метод в производен клас
        по време на изпълнение се определя коя версия на метода да
        се изпълни /базовата или предефинираната/ на основа на типа
        на обекта. Това е известно като <b>късно свързване /late binding/</b>.</p>
    <p><b>Късното свързване</b> се постига чрез използването на ключовите
        думи <b>virtual</b>, <b>override</b> и <b>base</b>. Ключовата
        дума <b>virtual</b> се използва за деклариране на метод в базовия
        клас като подлежащ на замяна, а ключовата дума <b>override</b>
        се използва в производния клас, за да покаже, че даден метод
        заменя метод на базов клас. Ключовата дума <b>base</b> се използва
        за препращане към базовия клас от производен клас, което ви
        позволява да извикате метода/полето на базовия клас от наследен
        предефиниран /земенен/ метод.</p>
    <p>Ключова дума <b>base </b>се използва за препратка към базовия клас
        от производен клас. Позволява достъп до членове (методи, свойства,
        полета) на базовия клас, които са  предефинирани в производния
        клас /но само ако са protected или public/. </p>
    <p>Ключова дума <b>this</b> се отнася до текущия екземпляр на класа.
        Използва се за достъп до членове (полета, свойства, методи)
        на текущия клас. Позволява достъп до методи/полета на текущия
        клас. Изричното използване на <b>this</b> помогa за разграничаване
        между полета и методи на текущия клас, и полета и методи на
        неговия базов клас, когато имат едно и също име.</p>
    <p><b>Mодификатори на методите/класовете /освен:</b></p>
    <p>•<b> sealed</b>: Тази ключова дума указва, че даден <b>клас / метод</b>
        не може да бъде наследен. Това е полезно за да предотвратите
        нежелани модификации или разширения. Чрез запечатването на
        клас вие гарантирате, че поведението му остава непроменено
        и не може да бъде заменено от производни класове.</p>
    <p>•<b> abstract</b>: Тази ключова дума указва, че дадените методи трябва
        да бъдат имплементирани от наследяващи <b>класове / методи</b>.</p>
    <p>•<b> virtual</b>: Тази ключова дума указва, че даден <b>метод</b>
    може да бъде заменен в наследяващи класове.</p>
    <p>•<b> override</b>: Тази ключова дума указва, че даден <b>метод</b>
    замества /презаписва/ метод на базов клас.</p>
    <p><b>Модификатори
        на достъпа на методите / полетата</b></p>
    <p>•<b> public</b>: Публичен член може да бъде достъпен от всяко място
        в кода, независимо дали е от същия клас, производен клас или
        различен assembly /<b>assembly</b> - изпънимият .<b>exe </b>файл,
        плюс всички останали .<b>dll </b>файлове, от които зависи/.
        Осигурява най-високо ниво на достъпност. <b>public</b> често
        се използва за членове, които трябва да бъдат достъпни от множество
        части на програма или от външни компоненти. Когато клас или
        интерфейс е маркиран като <b>public</b>, това означава, че
        той може да бъде създаден или наследен от друг код. </p>
    <p>•<b> private</b>: Частен член може да бъде достъпен само от същия
        клас. Това е модификаторът за достъп по подразбиране за членовете
        на класа, ако не е указан модификатор за достъп. <b>private
        </b>членовете капсулират подробностите за тяхното изпълнение и са
        скрити от другите части на програмата. Това помага да се поддържа
        целостта на данните и насърчава по-добра организация и капсулиране
        на кода, и позволява по-добър контрол върху вътрешната работа
        на класа. </p>
    <p>•<b> protected</b>: Защитен член може да бъде достъпен от същия
        клас или производни класове, но не и извън класа или assembly.
        Те не са достъпни извън йерархията на класовете. Модификаторът
        <b>protected</b> е полезен, когато искате да споделите определени
        членове с производни наследяващи класове, като същевременно
        ги държите скрити от други несвързани класове. Това помага
        при повторното използване на кода и насърчава на правилни взаимоотношения
        между класовете в йерархията.</p>
    <p>•<b> internal</b>: Вътрешен член може да бъде достъпен от рамките
        на същия assembly, но не и извън него. <b>internal</b> осигурява
        начин за капсулиране на подробности за изпълнението и скриването
        им от външен код. Помага при организирането и разделянето на
        кода на логически единици в рамките на проект или решение.
        Това насърчава капсулирането и модулността на кода.</p>
    <p>•<b> protected internal</b>: Защитен вътрешен член може да бъде
        достъпен от същия assembly или производни класове в други assembly.
        Той съчетава достъпността на <b>protected</b> и <b>internal</b>.</p>
    <p>•<b> private protected: </b>членовете могат да бъдат достъпни в
        рамките на класа, който ги дефинира, както и от всички производни
        класове, които са дефинирани в същия асембли. Те обаче не могат
        да бъдат достъпни от производни класове в други асембли. Той
        позволява достъп в рамките на същото assembly , но не извън
        него или от непроизводни класове в други assembly.</p>
    <p>Пример с <b>private protected </b>и наследяване на класа <b>MyClass </b>от
        класа <b>MyDerivedClass</b> </p>
            

<pre class='pre'>
using System;
namespace MyNamespace
{
    class MyClass
    {
        <b>private protected </b>int myInt = 42;
    }
    
    class MyDerivedClass : MyClass // наследяваме <b>MyDerivedClass</b>от класа <b>MyClass</b>
    {
        void MyMethod()
        {
            Console.WriteLine(myInt); // Това е позволено, защото MyDerivedClass 
                                      // е в същото assembly като MyClass
        }
    }
    
    class Program 
    {
        public static void Main()
        {
            MyDerivedClass ob = new MyDerivedClass();
            ob.MyMethod();
        }
    }
    
}

// Резултат:
// 42
</pre>

    <p><b>Интерфейси</b></p>
    <p>Интерфейсите в C# предоставят начин за дефиниране на <b>договор</b>
        /<b>contract</b>/ - набор  от методи, свойства, събития или
        променливи, които наследяващия клас трябва да притежава /имплементира/.
        </p>
    <p>Интерфейсите дефинират членове: Интерфейсите могат да включват
        сигнатури на <b>методи</b>, декларации на <b>свойства</b>,
        декларации на <b>събития</b> и декларации на <b>индексатор</b>.
        Комплекта от тези членове определят <b>договора</b>, към който
        трябва да се придържат изпълняващите /наследяващите/ класове.</p>
    <p>Интерфейсите могат да наследяват от други интерфейси, образувайки
        йерархия на наследяване. Клас, който имплементира даден интерфейс,
        също имплементира всички интерфейси, наследени от този интерфейс.</p>
    <p>Внедряване на интерфейси: Един клас може да имплементира един или
        <b>няколко</b> интерфейси, като предоставя необходимата реализация
        за всеки член, дефиниран в интерфейса /интерфейсите/, за разликата
        при наследяване на клас от базов клас, когато даден клас може
        да наследи само <b>един</b> базов клас. Пример:</p>
            
<pre class='pre'>
class MyClass : Interface1, Interface2 // <b>MyClass</b> наследява <b>Interface1 </b>и <b>Interface2</b> 
{
    // Class implementation
}
</pre>

    <p>Интерфейсите се използват за постигане на абстракция, полиморфизъм
        и повторно използване на кода. Те ви позволяват да пишете код,
        който работи с обекти от различни класове, стига да реализират
        необходимия интерфейс. Те спомагат за насърчаване на <b>слбо свързване</b>
        /loose coupling/, модулността и гъвкавостта във вашия код,
        което улеснява писането на поддържаеми и разширяеми приложения.</p>
    <p><b>Слабото свързване /</b>loose coupling<b>/ </b>е принцип в обектно-ориентираното
        програмиране, който насърчава независимостта и гъвкавостта
        на компонентите или модулите в системата с останалите компоненти
        или модули. Той набляга на намаляването на зависимостите между
        компонентите, което им позволява лесно да бъдат заменени, без
        да се засягат други части на системата. То спомага за подобряване
        на поддържаемостта на кода, повторната употреба и възможността
        за тестване, както и улеснява модулните и мащабируеми софтуерни
        архитектури.</p>
    <p><b>Пример за интерфейс</b></p>
    
<pre class='pre'>
using System;

// Дефиниране на <b>interface</b>
public <b>interface <span class='blu'>IShape</span></b>
{
    double <b>CalculateArea</b>(); // внедряващите /наследяващите/ този интерфейс 
                            // класове задължително трябва да имат 
                            // този метод /<b>договор</b>/
}

// Внедряване на <b>интерфейса <span class='blu'>IShape </span></b>в клас <b>Circle</b> 
public class <b>Circle</b> : <b><span class='blu'>IShape</span></b>
{
    private double radius;
    public <b>Circle</b>(double radius)  // <b>конструктор </b>на клас <b>Circle</b>
    {
        this.radius = radius;
    }
    public double <b><span class='red'>CalculateArea</span></b>() // <b><span class='blu'>IShape </span></b>ни "задължава" да имаме такъв метод
    {                             // в класа <b>Circle</b>, чрез <b>"договор"</b>
        return Math.PI * Math.Pow(radius, 2);
    }
}


// Внедряване на <b>интерфейса <span class='blu'>IShape </span></b>в клас <b>Rectangle </b> 
public class <b>Rectangle </b>: <b><span class='blu'>IShape </span></b>
{
    private double width;
    private double height;

    public <b>Rectangle</b>(double width, double height) // <b>конструктор </b>на клас <b>Rectangle</b>
    {
        this.width = width;
        this.height = height;
    }

    public double <b><span class='ora'>CalculateArea</span></b>() // <b><span class='blu'>IShape </span></b>ни "задължава" да имаме такъв метод
    {                             // в класа <b>Rectangle</b>, чрез <b>"договор"</b>
        return width * height;
    }
}

// Употреба на <b>интерфейс</b>
public class Program
{
    public static void Main()
    {
        // Създаване на 2 обекта, които внедряват интерфейса <b><span class='blu'>IShape </span></b> 
        // с new ги създаваме от различни класове
        <b><span class='blu'>IShape </span></b>circle = new Circle(5); // и 2-та обекта са тип <b><span class='blu'>IShape </span></b>
        <b><span class='blu'>IShape </span></b>rectangle = new Rectangle(4, 6);   
         
       
        // Извикваме метода на <b>interface</b> на различни обекти:
        // 1. извиква се метод <b><span class='red'>CalculateArea</span> от клас Circle:</b>
        double circleArea = circle.<b><span class='red'>CalculateArea</span></b>();

        // 2. извиква се метод <b><span class='ora'>CalculateArea </span>от клас Rectangle:</b>
        double rectangleArea = rectangle.<b><span class='ora'>CalculateArea</span></b>();

        // 3.извеждане на резултата
        Console.WriteLine("Circle area: " + circleArea);
        Console.WriteLine("Rectangle area: " + rectangleArea);
    }
}

// Резултат:
// Circle area: 78.53981633974483
// Rectangle area: 24
</pre>


    <p>В този пример ние дефинираме интерфейс, наречен <b><span class='blu'>IShape</span></b>,
        който декларира метод <b>CalculateArea</b>(). След това имплементираме
        интерфейса <b><span class='blu'>IShape </span></b>в два класа:
        <b>Circle</b> и <b>Rectangle</b>, предоставяйки техните собствени
        реализации на метода <b>CalculateArea</b>().</p>
    <p>В класа <b>Program</b> създаваме обекти <b>Circle </b>и <b>Rectangle </b>и
        ги присвояваме на променливи от тип <b><span class='blu'>IShape</span></b>,
        което е възможно, тъй като внедряват /имплементират/ един и
        същи интерфейс /<b><span class='blu'>IShape</span></b>/. След
        това извикваме метода <b>CalculateArea</b>() за всеки обект,
        като при това автоматично се извиква подходящата реализация
        на метода въз основа на действителния тип на обекта. Това демонстрира
        как интерфейсите позволяват да работим с обекти от различни
        класове чрез общ интерфейс, позволявайки <b>полиморфизъм</b>            
        и осигурявайки гъвкавост при използването на кода.</p>
    <p><b>Опаковането</b> и <b>разопаковането</b> на класове се отнася
        до процеса на <b>сериализиране</b> и <b>десериализиране</b>            
        на обекти. Сериализацията е процес на преобразуване на обект
        във формат, който може да се съхранява или предава, като бинарен
        /двоичен/, <b>XML</b> или <b>JSON</b>. Това позволява да се
        запазите състоянието на обект или да го изпратите по мрежата.
        Десериализацията, е процес на пресъздаване на обект от неговата
        сериализирана форма. C# предоставя вградени механизми за сериализация
        и десериализация, като <b>BinaryFormatter</b>, <b>XmlSerializer</b>            
        и <b>JsonSerializer /JSON - </b>Javascript Object Notation
        <b>- </b>формат на низове с директна поддръжка от клиентския
        програмен език в web-browsera <b>Javascript, </b>както и от
        повечето съвременни програмни езици<b>/</b>. Тези класове ви
        позволяват лесно да опаковате обекти в сериализиран формат
        и да ги разопаковате обратно в обекти. Сериализацията е полезна
        в сценарии като запазване, зареждане на данни, комуникация
        между процеси, както и при комуникация между програми написани
        на различни програмни езици. Позволява обектите да бъдат съхранявани
        или предавани по структуриран начин, запазвайки тяхното състояние.</p>

<pre class='pre'>
using System;
using System.Text.Json; // библиотека за сериализация във формат JSON

class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

class Program
{
    static void Main()
    {
        // Обект, който ще бъде сериализиран
        var person = new Person
        {
            Name = "John Doe",
            Age = 30
        };
        
        // Сериализация на обекта в <b>JSON </b>низ
        string jsonString = JsonSerializer.Serialize(person);
        
        // извеждане на екрана на получения <b>JSON</b> - низ
        Console.WriteLine($"JSON string: {jsonString}");
        
        // Десериализация на <b>JSON </b>низа обратно в обект
        var deserializedPerson = JsonSerializer.Deserialize&lt;Person&gt;(jsonString);
        
        Console.WriteLine($"Name: {deserializedPerson.Name});
        Console.WriteLine($"Age: {deserializedPerson.Age}");
    }
}

<b>// Резултат</b>:
// JSOn string: {"Name":"John Doe","Age":30}
// Name: John Doe
// Age: 30 
</pre>

    <p>В този пример дефинираме клас <b>Person</b> със свойства <b>Name</b> и <b>Age</b>. 
        Създаваме екземпляр на класа <b>Person</b>, сериализираме
        го в <b>JSON</b> низ с помощта на <b>JsonSerializer.Serialize</b>,
        след това извеждаме на екрана получения сериализиран <b>JSON</b>
        низ, десериализираме обратно в обект с помощта на <b>JsonSerializer. Deserialize,</b>
        накрая извеждаме и стойностите на свойствата на десериализирания
        обект - <b>Name</b> и <b>Age</b>.</p>
    
    <p>Освен единични обекти, можем да сериализираме и списък /динамичен масив/ от няколко
       обекта, като освен това ги запишем и във файл. Със <b>echo "[]" > data.json</b> се създава файла <b>data.json</b> 
       със съдържание <b>[]</b>, за да има валиден JSON файл който може да се зареди.</p>
           
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank $ mkdir jsonfile
@404joe ➜ /workspaces/codespaces-blank/jsonfile $ dotnet new console
@404joe ➜ /workspaces/codespaces-blank/jsonfile $ echo "[]" > data.json
</pre>
    <p>В Program.cs добавте следния код, който добавя по 1 запис към файла data.json при    
       всяко стартиране на програмата:</p>

<pre class='pre'>
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;

public struct Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

class Program
{
    static void Main()
    {
        // Read the JSON file and load the list of Person objects
        string jsonr = File.ReadAllText("data.json"); // Може и System.IO.File.ReadAllText, без да включвате System.IO
        List&lt;Person&gt; personList = JsonSerializer.Deserialize&lt;List&lt;Person&gt;&gt;(jsonr);

        // Create a new Person object and add it to the list
        Person newPerson = new Person { Name = "John Doe", Age = 24 };
        personList.Add(newPerson);

        // Convert the list of objects to JSON format
        string jsonw = JsonSerializer.Serialize(personList);

        // Save the updated list back to the JSON file
        File.WriteAllText("data.json", jsonw);        // Може и System.IO.File.WriteAllText, без да включвате System.IO
    }
}

// Резултат /data.json/:
// [
//   {
//     "Name": "John Doe",
//     "Age": 24
//   }
// ]
</pre>
        
        
    <hr>
    
    
    <h2 id='VII'>VII. Събития, Изключения, Файлове</h2>
    <p><b>Събития</b></p>
    <p>Събитията /<b>events</b>/ в C# са начин за комуникация между компоненти
        или обекти. Те позволяват на един обект да уведоми други обекти,
        когато настъпи конкретно действие или промяна на състоянието.
        Едно събитие се състои от манипулатор /<b>handler</b>/ на събитие
        - <b>метод</b>, който се извиква автоматично, когато събитието
        се случи /raise/.</p>
    <p><b>Пример:</b></p>
        
<pre class='pre'>
// Define a class with an event
class Button
{
    // Define the event
    public event EventHandler Click;
    // Method to raise the event
    public void OnClick()
    {
        // Check if any subscribers are registered
        if (Click != null)
        {
            // Raise the event
            Click(this, EventArgs.Empty);
        }
    }
}

// Usage example
class Program
{
    static void Main()
    {
        Button button = new Button();
        // Subscribe to the Click event
        button.Click += Button_Click;
        
        // Simulate a button click
        button.OnClick();
    }
    
    static void Button_Click(object sender, EventArgs e)
    {
        Console.WriteLine("Button clicked!");
    }
}
</pre>
        
    <p>В този пример дефинираме клас <b>Button </b>със събитие <b>Click</b>.
        Класът <b>Button</b> също има метод <b>OnClick</b>(), който
        предизвиква събитието. В метода <b>Main</b>() създаваме екземпляр
        на <b>Button</b>, <b><span class='red'>абонираме </span></b>се
        за събитието <b>Click </b>с помощта на оператора <b><span class='red'>+=</span></b>
        и след това симулираме щракване на бутон чрез извикване на
        метода <b>OnClick</b>(). Когато събитието е повдигнато, методът
        <b>Button_Click </b>се изпълнява и той извежда съобщение "Button
        clicked!" в конзолата.</p>
    <p><b>Забележка</b>: В сценарии от реалния свят събитията често се
        използват в значително по-сложни системи с множество абонати
        и аргументи на събитието.
        <br>
        <br> При разработка на Windows Forms приложение, можете да прикачите
        събития към различни контроли като <b>бутони</b>, <b>текстови полета</b>
        или <b>менюта</b>. Тези събития се изпълняват, когато се повдигне
        свързаното събитие, което ви позволява да пишете код, който
        отговаря на потребителски действия, като щраквания на бутони,
        движения на мишката или въвеждане от клавиатурата. По подобен
        начин можете да обработвате събития като <b>TextChanged</b>,
        <b>KeyPress</b>, <b>MouseEnter</b> и много други, за да контролирате
        поведението на вашето приложение въз основа на потребителски
        взаимодействия. Чрез използване на събития можете да създавате
        интерактивни и отзивчиви потребителски интерфейси в приложения
        на <b>Windows Forms</b>.</p>
    <hr>
    <p><b>Обработка на изключения /грешки, Exceptions/</b></p>
    <p>При работа с различни функции, особено в интернет, може да възникнат
        изключения /грешки/ - примерно прекъсване на връзка, гршка
        при изпълнението на дадена функция, и др. В тези случаи може
        да се използва <b>try/catch/finally блок, </b>за обработка
        на изключения/грешки. В <b>try</b> блока се поставя функцията,
        която може да предизвика грешка; в <b>catch</b> блока се извежда
        съобщението за грешка, а във <b>finally</b> блока се почиства
        обекта, който е дал грешка. Следния пример, хвърля грешка при
        опит за конвертиране към <b>int</b> /цяло число/ на символен низ.
            
<pre class='pre'>
int a = 10;
try {
    a = int.Parse("300");          
    Console.WriteLine("a = " + a); // Ok 
    a = int.Parse("Hold my beer"); // Rise exception!
    Console.WriteLine("a = " + a); // Never reached
} 
catch ( FormatException ex )       // <span class='grn'>Save the day</span>
{
    Console.WriteLine("0. EXCEPTION! Beer NOT hold, Reason : " + <span class='yel'>ex.Message</span> );
}

a = int.Parse("Hold my beer");             // <span class='red'>Rise exception! ➜ &#x2716; Program termination &#x2716;</span>
Console.WriteLine("2. Beer on hold:" + a); // Never reached 


// Резултат:
// a = 300
// 0. EXCEPTION! Beer NOT hold, Reason : <span class='yel'>The input string 'Hold my beer' was not in a correct format.</span>
// Unhandled exception. System.FormatException: The input string 'Hold my beer' was not in a correct format.
//    at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, ReadOnlySpan`1 value, TypeCode type)
//    at System.Int32.Parse(String s)
//    at Program.&lt;Main&gt;$(String[] args) in /workspaces/codespaces-blank/exc/Program.cs:line 12
</pre>            
            
            
    <p>Следния пример, демонстрира изпълнение
    на <b>GET</b> заявка към примерно <b>Web API</b> /Web Application
    Program Interface - стандартна услуга в интернет, която връща
    <b>JSON</b> низове от даден Web адрес - например
    <a href='https://jsonplaceholder.typicode.com/posts/' target='_blank' class='lnk'>https://jsonplaceholder.typicode.com/posts/</a>
    - отворете го с мишката<b>!!!</b> / с помощта на обекта <b>HttpClient</b>
    и обработка на потенциални грешки <b>/exceptions/</b> с помощта
    на блок <b>try/catch/finally:</b></p>
            
<pre class='pre'>
using System;
using System.Net.Http; // необходимо заради <b>HttpClient</b> обекта
class Program
{
    // функцията <b>Main</b> е <b>асинхронна</b>, във <b>II Част</b> на курса ще 
    // бъде разгледана по-подробно
    <b><span class='blu'>static async System.Threading.Tasks.Task </span></b>Main()
    {
        HttpClient client = new HttpClient();
        string url = <span class='blu'>"https://jsonplaceholder.typicode.com/posts"</span>;
        <b>try</b>
        {
            string response = <b><span class='blu'>await </span></b>client.<b>GetStringAsync</b>(url);
            // <b><span class='blu'>await </span></b>- във <b>II Част</b>
            Console.WriteLine("Response: " + response);
        }
        <b>catch </b>(HttpRequestException ex)
        {
            Console.WriteLine("An error occurred: " + ex.Message);
        }
        <b>finally</b>
        {
            client.Dispose();
        }
    }
}
</pre>

    <p>В този пример създаваме обект от класа <b>HttpClient </b>и правим
        <b>GET</b> заявка към посочения <b>URL</b> адрес с помощта
        на метода <b>GetStringAsync</b>. Блока <b>try</b> се изпълнява
        винаги, като в него изчакваме отговора и го показваме в конзолата.
        Ако възникне грешка /изключение/ по време на заявката, блока
        <b>catch </b>се изпълнява автоматично, грешката се улавя и
        се извежда съобщение за вида на грешката. Блокът <b>finally</b>
        се изпълнява винаги, за да се гарантира, че <b>HttpClient</b>
        е правилно освободен, независимо дали е възникнало изключение
        или не.</p>
    <p>Не забравяйте да обработвате изключенията по начин, който предоставя
        значима обратна връзка на потребителя /извежда подходящо <b>съобщение</b>
        за възникналата грешка/ и предприема подходящи действия /<b>освобождаване на обекта</b>,
        хвърлил грешката/ въз основа на конкретния сценарий.</p>
    <p><b>checked</b> и <b>unchecked</b></p>
    <p>В C# ключовите думи <b>checked</b> и <b>unchecked</b> се използват
        за контролиране на поведението на целочислени аритметични операции
        /<b>int</b>/ по отношение на проверка при препълване. </p>
    <p>По подразбиране C# извършва аритметични операции с цели числа с
        <b>checked</b> проверка за препълване. Това означава, че ако
        аритметична операция доведе до препълване (напр. добавяне на
        две големи положителни цели числа, което води до стойност над
        максималната граница за типа данни), тя ще хвърли OverflowException.
        Ключовата дума <b>checked
    </b>изрично позволява проверка на препълване за блок от код, като
          гарантира, че всички аритметични операции в този блок ще хвърлят
          изключение, ако възникне препълване:</p>
            
<pre class='pre'>
<b>checked</b>
{
    int x = int.MaxValue; // x ➜ <b>Максималната</b> стойност за типа int
    int y = 1;
    int result = x + y;  // Този код ще хвърли грешка <b>OverflowException,</b>
    // защото <b>Максималната</b> стойност се прехвърля с <b>1</b>
}
</pre>


    <p><b>unchecked</b> позволява извършването на аритметични операции
        без проверка за препълване. Ако възникне препълване по време
        на операция, то резултата започва за нараства от <b>Минималната</b>            
        стойност за типа <b>int</b>, което може да доведе до неочаквани
        резултати:</p>
            
<pre class='pre'>
<b>unchecked</b>
{
    int x = int.MaxValue;
    int y = 1;
    int result = x + y;  // резултата се прехвърля в най-малкото отрицатено число за <b>int</b>
}
</pre>

    <p>Важно е да се отбележи, че <b>checked</b>  и <b>unchecked</b> блокове
        влияят основно върху <b>целочислените</b> /<b>int</b>/ аритметични
        операции (<b>+</b>, <b>-</b>, <b>*</b>,<b> /</b>, <b>%</b>
        и т.н.). Те нямат влияние върху аритметика с плаваща запетая
        /<b>float</b>, <b>double</b>/ или други видове данни.</p>
    <hr>
    <p><b>Четене от файл и запис във файл</b></p>
    <p>Ето кратък пример за това как можете да запишете <b>Unicode</b>/<b>UTF-8</b>
    низ от променлива във файл и след това да го прочетете обратно
        в друга променлива:</p>

<pre class='pre'>
using System.Text;

// низ на различни езици /<b>UTF-8</b>/, който ще запишем във файл 
string <b><span class='grn'>wStr</span></b> = "Hold my beer, ビールを預けておいてください, Подержи мое пиво!";
Console.WriteLine("Original String: " + <b><span class='grn'>wStr</span></b>); // Показване на оригиналния низ
string <b><span class='blu'>filePath </span></b>= "<span class='blu'>output.txt</span>";
// Записване на <b><span class='grn'>wStr </span></b>във файл с име <b><span class='blu'>output.txt</span></b>
File.WriteAllText(<b><span class='blu'>filePath</span></b>, <b><span class='grn'>wStr</span></b>);

// Четене на <b><span class='ora'>rStr </span></b>от същия файл /<b>output.txt/</b>
string <b><span class='ora'>rStr</span></b> = File.ReadAllText(<b><span class='blu'>filePath</span></b>);

Console.WriteLine("Read String: " + <b><span class='ora'>rStr</span></b>); // Показване на прочетения низ

<b>// Резултат:</b>
// Write String: Hold my beer, ビールを預けておいてください, Подержи мое пиво!
// Read String: Hold my beer, ビールを預けておいてください, Подержи мое пиво!
</pre>

    <p>В този пример първо извеждаме на екрана оригиналният низ - <b><span class='grn'>wStr</span></b>.
        След това използваме обект <b>File.WriteAllText</b>, за да запише
        низа от променливата <b>wStr</b> във файл, името на който е
        зададен в променливата <b><span class='blu'>filePath</span></b>.</p>
    <p>След това използваме обект <b>File.ReadAllText</b>, за да прочетем съдържанието
        на файла обратно в променливата <b><span class='ora'>rStr</span></b>. 
        Накрая показваме прочетения низ - <b><span class='ora'>rStr</span></b>, за да 
        проверим дали данните са записани и прочетени правилно. </p>
        
    <hr>        
    
    <h2 id='VIII'>VIII. Приложения за WEB: Razor × Blazor × SignalR</h2>
    <p><b>Кратко описание на Razor, Blazor и SignalR</b></p>
    <p><b>Razor </b>ви позволява да създавате динамични уеб страници в
        ASP.NET. Това е сървърна технология, разработена от Microsoft
        и се използва предимно в комбинация с ASP.NET Core. Razor предоставя
        чист и ефективен начин за смесване на HTML маркиране с C# код
        за генериране на динамично съдържание на сървъра и изобразяването
        му в уеб браузъра на клиента.</p>
    <p><b>Blazor </b>е иновативна уеб технология, също разработена от
        Microsoft. Тя ви позволява да създавате интерактивни уеб приложения,
        използвайки C# вместо JavaScript. Blazor използва технологията
        WebAssembly, за да изпълнява C# код директно в браузъра, което
        позволява на разработчиците да създават богати и интерактивни
        приложения от страна на клиента. С Blazor можете да напишете
        логиката на приложението си на C# и да го накарате да се изпълни
        от страна на клиента, докато безпроблемно взаимодействате с
        бекенда от страната на сървъра.</p>
    <p><b>SignalR </b>е рамка за уеб комуникация в реално време, предоставена
        от Microsoft. Тя опростява разработването на приложения в реално
        време, като позволява двупосочна комуникация между сървъра
        и клиента. SignalR използва различни техники, като WebSockets,
        изпратени от сървъра събития и дълго запитване /long pooling/,
        за да установи постоянна връзка между клиента и сървъра. Това
        позволява поточно предаване на данни в реално време, насочени
        известия и функции за сътрудничество в между клиентите. SignalR
        се използва широко в приложения, които изискват актуализации
        в реално време, като приложения за чат, тикери на борсата,
        инструменти за съвместно редактиране на документи и др.</p>
    <p>В обобщение, <b>Razor</b> е програмен модел за създаване на динамични
        уеб страници на сървъра, <b>Blazor</b> е уеб технология, която
        ви позволява да създавате интерактивни уеб приложения с на
        езика C# и да ги изпълнявате в уеб-броузъра, а <b>SignalR</b>
        е технология за уеб комуникация в реално време за актуализации
        в реално време между сървъра и клиента.</p>
    <p><b>SignalR </b></p>
    <p><b>SignalR </b>е техология за комуникация с уеб приложения в реално
        време, разработена от <b>Microsoft </b>за платформата .NET. Той позволява двупосочна 
        комуникация между сървъра и клиенти, позволявайки актуализации в реално време
        и интерактивни функции в уеб приложенията. Ето кратка информация
        за SignalR:</p>
    <p>Комуникация в <b>реално време</b>: SignalR опростява комуникацията в реално време между сървъра
        и свързаните клиенти, като позволява незабавни актуализации
        на данни, известия и взаимодействие на живо без необходимост
        от постоянно опресняване на уеб страницата.</p>
    <p><b>Двупосочна комуникация</b>: SignalR поддържа както комуникация от сървъра към
        клиенти (излъчване), така и комуникация от клиенти към сървър.
        Той позволява на сървъра да изпраща данни или съобщения към
        множество свързани клиенти едновременно, а клиентите могат
        също да изпращат данни или да извикват методи от страна на
        сървъра.</p>
    <p>Транспорт и управление на връзките: SignalR автоматично избира
        най-добрия наличен транспортен механизъм въз основа на възможностите
        на клиента и поддръжката на браузъра. Той поддържа различни
        опции за транспорт като <b>WebSockets</b>, сървърно-изпратени
        събития (<b>SSE</b>), <b>AJAX</b> и др. Той също така управлява
        връзките, като се справя прозрачно с повторни свързвания и
        неуспешни връзки.</p>
    <p>Мащабируемост и балансиране на натоварването: SignalR поддържа
        мащабиране в множество физически сървъри, което позволява работа
        с голям брой свързани клиенти и разпределяне на работното натоварване.
        Той осигурява реализации на задния край /сървъри/, които позволяват
        комуникация между отделните физически сървъри и гарантира,
        че съобщенията се излъчват до всички свързани клиенти.</p>
    <p><b>Хъбове</b> и постоянни връзки: SignalR предоставя абстракция
        на високо ниво, наречена „Хъбове“, която опростява процеса
        на управление на комуникацията клиент-сървър. Хъбовете позволяват
        на клиенти и сървъри да извикват методи един на друг директно.
        Като алтернатива, SignalR също поддържа "постоянни връзки"
        от по-ниско ниво за по-персонализирани комуникационни изисквания.</p>
    <p>Поддръжка на различни платформи: SignalR не е ограничен до .NET
        framework; предоставя клиентски библиотеки за различни платформи,
        включително JavaScript, .NET (C#), Java, Python и др. Това
        позволява изграждането на приложения в реално време, които
        могат безпроблемно да комуникират между различни клиентски
        платформи.</p>
    <p>SignalR е широко възприет за разработване на функции в реално време
        в уеб приложения, като приложения за чат, инструменти за сътрудничество,
        табла за управление в реално време, приложения за игри и др.
        Той опростява сложността на комуникацията в реално време и
        предоставя мощна рамка за изграждане на интерактивни и отзивчиви
        уеб преживявания на платформата .<b>NET</b>.</p>
    <p><b>Кратко описание на основни Интернет понятия</b></p>
    <p><b>HTML</b> файлът е текстов файл с разширение ".html",
        който съдържа инструкции за маркиране с помощта на HTML (<b>Hypertext Markup Language</b>).
        Това е стандартният език за създаване на уеб страници и определяне
        на тяхната структура и съдържание.</p>
    <p>Съдържанието на HTML файл обикновено се състои от различни елементи
        и тагове, които определят структурата и представянето на уеб
        страницата. Ето някои ключови компоненти, които можете да намерите
        в HTML файл:</p>
    <p>Декларация за типа на документа (<b>DOCTYPE</b>): Той указва използваната
        версия на HTML, което помага на браузърите да разберат как
        да интерпретират и изобразяват страницата.</p>
    <p><b>&lt;html&gt;</b>: Основният елемент на HTML файл, който съдържа
        всички останали елементи на уеб страницата.</p>
    <p><b>&lt;head&gt;</b>: Този раздел включва метаданни за документа,
        като заглавие на страницата, кодиране на символи, използвани
        <b>CSS</b> стилове, <b>JavaScript</b> файлове и други. </p>
    <p><b>&lt;body&gt;</b>: Елементът &lt;body&gt; съдържа видимото съдържание
        на уеб страницата, включително текст, изображения, връзки,
        заглавия, параграфи и други HTML елементи.</p>
    <p><b>Тагове</b></p>
    <p>HTML <b>таговете</b> се използват за дефиниране и структуриране
        на съдържанието на уеб страницата. Примерите включват &lt;<b>h1</b>&gt;
        за заглавия, &lt;<b>p</b>&gt; за параграфи, &lt;<b>img</b>&gt;
        за изображения, &lt;<b>a</b>&gt; за хипер-връзки към други
        страници, и много други. Таговете могат също така да имат <b>атрибути</b>,
        които предоставят допълнителна информация или променят тяхното
        поведение.</p>
    <p>Коментари: HTML ви позволява да добавяте коментари в кода, като
        използвате &lt;!-- коментар --&gt;. Тези коментари се игнорират
        от браузъра и са полезни за документиране или временно деактивиране
        на части от кода.</p>
    <p>Като цяло един HTML файл предоставя начин за структуриране и представяне
        на информация в мрежата. Той съчетава текстово съдържание,
        мултимедийни елементи и инструкции за форматиране, за да създаде
        интерактивна уеб страница, която може да бъде изобразена и
        показана от уеб браузъри.</p>
    <p><b>По-важни тагове</b></p>
    <p>&lt;<b>div</b>&gt;: Тагът &lt;div&gt; е контейнерен елемент, използван
        за групиране на други HTML елементи заедно. Обикновено се използва
        за целите на оформлението и помага за организиране и стилизиране
        на различни секции от уеб страница.</p>
    <p>&lt;<b>input</b> type="<b>text</b>"&gt;: Тагът &lt;input&gt;
          с атрибута type="text" създава поле за въвеждане
          на текст в <b>HTML</b> формуляр. Позволява на потребителите
          да въвеждат и редактират текст.</p>
    <p>&lt;<b>input </b>type="<b>button</b>"&gt;: Тагът &lt;input&gt;
          с атрибута type="button" създава бутон, върху който
          може да се кликне, на уеб страница. Обикновено се използва
          за задействане на конкретно действие или събитие, когато потребителят
          щракне върху него.</p>
    <p>&lt;<b>ul</b>&gt; и &lt;<b>li</b>&gt;: Таговете &lt;ul&gt; (неподреден
          списък) и &lt;li&gt; (елемент от списък) се използват заедно
          за създаване на списък в HTML. Тагът &lt;<b>ul</b>&gt; представлява
          контейнера за списъка и всеки отделен елемент се дефинира с
          помощта на тага &lt;li&gt;.</p>
    <p>&lt;<b>script</b>&gt;: Тагът &lt;<b>script</b>&gt; се използва
          за вграждане или препратка към JavaScript код в HTML документ.
          Тя ви позволява да добавяте интерактивност, да извършвате изчисления,
          да манипулирате HTML съдържанието и да обработвате събития
          на уеб страница на езика Javascript - със почти същия синтаксис
          като C#. </p>
          
    <p>Допълнителни атрибути: например тага &lt;div <b>id</b>='content' <b>class</b>='content'&gt;   
          Hold my beer &lt;/div&gt; има 2 атрибута: id /уникален идентификатор за целия HTML документ/ 
          и class /CSS стилов клас/, който отговаря за неговото стилизиране: представяне на екрана - 
          цвят, позиция, и др. . Всеки таг трябва да има затварящ таг, напр: &lt;/div&gt;</p>    
    <p>Сега нека обсъдим допълнителните <b>атрибути </b>на таговете, които
          споменахме:</p>
    <p><b>id</b> на таг се отнася до уникалния идентификатор, присвоен
          на даден HTML елемент с помощта на атрибута <b>id</b>. Той
          ви позволява да манипулирате конкретни елементи с помощта на
          JavaScript или CSS. Всеки идентификатор трябва да бъде уникален
          в рамките на HTML документа.</p>
    <p>Функции в <b>javascript</b></p>
    <p>функция <b>document.getElementById</b> е JavaScript метод, който
          ви позволява да посочите даден HTML елемент въз основа на неговия
          уникален идентификатор /<b>id</b>/. Можете да използвате този
          метод за достъп и промяна на свойствата, съдържанието или стила
          на конкретен елемент на уеб страницата.</p>
    <p><b>document.createElement</b>("li"): Този JavaScript
          код създава нов &lt;<b>li</b>&gt; елемент динамично с помощта
          на метода <b>createElement</b>. Той ви позволява да генерирате
          HTML елементи програмно, което може да бъде полезно за създаване
          на динамично съдържание или манипулиране на структурата на
          уеб страницата.</p>
    <p><b>appendChild</b> е метод в JavaScript, използван за вмъкване
          на новосъздаден или съществуващ елемент като поделемент на
          друг елемент. Той добавя посочения елемент като последния дъщерен
          елемент на целевия елемент, като ефективно го добавя към края
          на списъка с поделементи. Този метод често се използва за динамично
          добавяне или преместване на елементи в структурата на HTML
          документа.</p>
    <p><b>Javascript</b></p>
    <p>Когато HTML файл и JavaScript (JS) файл работят заедно от страна
          на клиента, те могат да създадат оживено и актуализирано в
          реално време уеб изживяване. Ето общ преглед от високо ниво
          на това как работят:</p>
    <p>HTML структура: HTML файлът осигурява структурата и първоначалното
          съдържание на уеб страницата. Той определя оформлението, заглавията,
          параграфите, изображенията и други елементи, които формират
          основата на потребителския интерфейс.</p>
    <p>Зареждане на <b>JavaScript</b>: В рамките на HTML файла обикновено
          има таг &lt;<b>script</b>&gt;, който препраща към външен <b>JS</b>
          файл. Например &lt;script src="script.js"&gt;&lt;/script&gt;.
          Това казва на браузъра да зареди и изпълни JS файла.</p>
    <p><b>Обработка на събития</b>: JavaScript ви позволява да дефинирате манипулатори
          на събития, които отговарят на потребителски взаимодействия
          или конкретни събития на уеб страницата. Например можете да
          следите за щраквания на бутони, изпращане на формуляри или
          движения на мишката. Когато възникне събитие, се изпълнява
          съответният JS код.</p>
    <p><b>Промяна </b>на <b>HTML</b>: С JavaScript можете да осъществявате
          достъп и да променяте <b>HTML</b> елементите. Това обикновено
          се прави с помощта на методи като <b>document.getElementById</b>
          или <b>document.querySelector</b> за избиране на конкретни
          елементи. След това можете динамично да променяте тяхното съдържание,
          стил или структура.</p>
    <p><b>AJAX </b>и <b>Fetch</b>: JavaScript предоставя механизми като
          AJAX (асинхронен JavaScript и XML) или <b>Fetch API</b> за отправяне на асинхронни заявки към сървъра без презареждане
          на цялата уеб страница. Това ви позволява да извличате данни
          от API или да изпращате данни към сървъра във фонов режим,
          позволявайки актуализации в реално време, без да прекъсвате
          работата на потребителя.</p>
    <p><b>Промяна </b>на <b>DOM /Document Object Model/</b>: Обектният
          модел на документа (DOM) е представяне на йерархията на HTML
          елементите като дървовидна структура в паметта. JavaScript
          може да взаимодейства с този <b>DOM</b>, добавяйки, модифицирайки
          или премахвайки динамично елементи. Например, можете да създадете
          нови <b>HTML </b>елементи, да актуализирате съдържанието им
          или да промените видимостта им въз основа на действията на
          потребителя или получените данни.</p>
    <p><b>Таймери и анимация</b>: JavaScript предлага функции като <b>setInterval</b> и 
        <b>requestAnimationFrame</b>, които ви позволяват да изпълнявате
          код на определени интервали или да синхронизирате представената
          в браузъра информация. Това позволява създаване на анимации,
          периодично актуализиране на съдържание или прилагане на визуални
          ефекти в реално време.</p>
    <p>Като комбинирате HTML структурата и динамичните възможности на
          JavaScript, можете да създадете интерактивни и отзивчиви уеб
          изживявания. JavaScript дава възможност за обработка на събития,
          манипулиране на HTML елементи, комуникация със сървъри и възможност
          за актуализиране на уеб страницата в реално време, което води
          до оживен и ангажиращ потребителски интерфейс.</p>
    <p><b>CSS</b></p>
      
    <p><b>CSS </b>(<b>Cascading Style Sheets</b>) играе решаваща роля в допълването на HTML и 
      JavaScript за подобряване на представянето и стила на уеб страниците. Ето как CSS се вписва в картината:</p>
    <p><b>CSS</b> разделя визуалното представяне на уеб страница от нейната
          структура и съдържание. Като съхранява инструкциите за стилизиране
          в отделен CSS файл или в &lt;<b>style</b>&gt; тагове, това
          позволява по-добра организация, поддръжка и повторна употреба
          на стилове в множество HTML страници.</p>
    <p><b>Стилизиране</b>на HTML елементи: CSS ви позволява да прилагате стилове към HTML
        елементи, дефинирани в HTML файла. Можете да изберете елементи
        с помощта на CSS селектори и да дефинирате различни свойства
        като цветове, шрифтове, размери, полета, рамки и други. Това
        ви позволява да персонализирате външния вид и оформлението
        на елементите, за да отговарят на вашите изисквания за дизайн.</p>
    <p>Отзивчив /<b>responsive</b>/ дизайн: CSS предоставя функции като
        медийни заявки, които ви позволяват да създавате отзивчив дизайн.
        С медийни заявки можете да дефинирате различни стилове за различни
        размери на екрана на различни устройства - таблети, телефони,
        компютри. Това гарантира, че вашата уеб страница се адаптира
        и изглежда добре на различни устройства, включително настолни
        компютри, таблети и мобилни телефони.</p>
    <p><b>Позициониране</b>: CSS предлага различни техники за оформление
        и позициониране на различните елементи на уеб страницата. Използвайки
        свойства като <b>display</b>, <b>float</b>, <b>position</b>
        и <b>CSS Grid</b> или <b>Flexbox</b>, можете да създавате сложни
        оформления, да подравнявате елементи и да контролирате тяхното
        позициониране в рамките на страницата.</p>
    <p><b>Bootstrap</b></p>
    <p>Най-голямото предимство на <a href='https://getbootstrap.com/' target='_blank' class='lnk'>Bootstrap</a>  
       е, че автоматично се включва във вашите проекти, ако са създадени с командата:</p>

<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank/holdmybeer $ <b>dotnet new webapp</b>
</pre>

    <p>За да използвате Bootstrap трябва да потърсите тага кoйто искате да стилизирате с CSS, да 
        му добавите съответния CSS клас. Например, търсите в интернет търсачката тага за таблица: 
        <b>'table tag bootstrap class'</b> и го добавяте във вашия HTML:</p>
            
<pre class='pre'>
&lt;table <span class='grn'>class='table'</span>&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;!-- ... --&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre>
           
    <p><b>Bootstrap</b> е популярна CSS библиотека, която предоставя колекция
        от предварително проектирани <b>CSS</b> и <b>JavaScript</b>
        компоненти, заедно с отзивчива система за подреждане на елементи.
        Някои предимства от използването на Bootstrap включват:</p>
    <p>Отзивчив дизайн: Bootstrap е създаден с оглед на принципите на
        отзивчивия дизайн, което улеснява създаването на уеб страници,
        които автоматично се адаптират към различни размери на екрана
        и устройства. Той осигурява отзивчива мрежова система и предварително
        дефинирани CSS класове за отзивчиво поведение.</p>
    <p>Bootstrap се предлага с широка гама от готови за използване компоненти
        като навигационни ленти, бутони, формуляри, модали и други.
        Тези компоненти могат лесно да бъдат интегрирани във вашия
        HTML код, което позволява бързо и ефективно създаване на професионално
        оформени уеб страници.</p>
    <p>Последователен и професионален външен вид: Bootstrap осигурява
        последователен и визуално привлекателен дизайнерски език. Неговите
        компоненти са стилизирани еднакво, осигурявайки сплотен и професионален
        вид на вашето уеб приложение.</p>
    <p>Персонализиране: Докато Bootstrap предоставя стилове и компоненти
        по подразбиране, той също така позволява персонализиране. Можете
        лесно да персонализирате CSS стиловете, за да може представянето
        да отговаря на изискванията за брандиране и дизайн на вашия
        проект. </p>
    <p>Съвместимост между различни браузъри: Bootstrap е проектиран да
        бъде съвместим със съвременните уеб браузъри, като гарантира,
        че вашите уеб страници изглеждат и функционират еднакво в различни
        браузъри и платформи.</p>
    <p>Като цяло CSS подобрява визуалното представяне на HTML елементите,
        докато библиотеки като Bootstrap предоставят предварително
        проектирани компоненти и стилове, които рационализират уеб
        разработката и помагат за създаване на отзивчиви и визуално
        привлекателни уеб изживявания.</p>
    <hr>
    <p><b>Задачи</b></p>
    
    
    <p> 1. <b>Razor:</b> Да пратим информация от Web фронтенда /броузера/ на задния край /на .cs програмата/,
        да я отпечатаме в конзолата, и да я върнем обратно на броузера. За целта изпълнете командите:</p>

<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank $ mkdir post
@404joe ➜ /workspaces/codespaces-blank $ cd post
@404joe ➜ /workspaces/codespaces-blank/post $ dotnet new webapp
</pre>


<p>В index.cshtml, POST форма, която прави POST заявка към задния край</p>
<pre class='pre'>
    &lt;form method="post"&gt;
        &lt;input type="text"  asp-for="Data" name="Data" /&gt;
        &lt;input type="submit" value="Submit" /&gt;
    &lt;/form&gt;
</pre>

<p>В index.cshtml.cs - Обработка на POST заявката:</p>

<pre class='pre'>
    // В класа IndexModel добавте : 

   [BindProperty]
   public string Data { get; set; } = "";

    
    public IActionResult OnPost(){  
            Console.WriteLine("--- MSG change --- ➜ post data:" + Data);
            return Page(); // Може и RedirectToPage("/Privacy");  
    }
</pre>

<p>Резултат 1:</p>
<p><img src="../img/image008.jpg" class='img' alt='Post Data'></p>
    
<p>Резултат 2:</p>
<p><img src="../img/image010.jpg" class='img' alt='Post Result'></p>

    <hr>
      
    <p> 2. SignalR: Ще създадем приложение за онлайн чат, както е показано в това ръководство:
        <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/signalr" target='_blank' class='lnk'>Asp NetCore SignalR</a>
        За целта изпълнете следните команди в Терминал: </p>
         
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank $ mkdir chat
@404joe ➜ /workspaces/codespaces-blank $ cd chat
@404joe ➜ /workspaces/codespaces-blank/chat $ dotnet new webapp
@404joe ➜ /workspaces/codespaces-blank/chat $ cd wwwroot
@404joe ➜ /workspaces/codespaces-blank/chat/wwwroot $ curl -O https://raw.githubusercontent.com/404joe/csharp/master/_examples/L-8-3-chat-signalr/wwwroot/signalr.js
</pre>

    <p>Следния HTML създава текстови полета и бутон за изпращане.
       Създава списък с id="messagesList" за показване на съобщения, получени от центъра на SignalR.
       Включва препратки към скриптове към SignalR и кодът на приложението chat.js</p>
    
    <p>В края на файла /chat/Pages/index.cshtml добавете:</p>
        
<pre class='pre'>
@page
&lt;div class="container"&gt;
    &lt;div class="row p-1"&gt;
        &lt;div class="col-1"&gt;User&lt;/div&gt;
        &lt;div class="col-5"&gt;&lt;input type="text" id="userInput" /&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row p-1"&gt;
        &lt;div class="col-1"&gt;Message&lt;/div&gt;
        &lt;div class="col-5"&gt;&lt;input type="text" class="w-100" id="messageInput" /&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row p-1"&gt;
        &lt;div class="col-6 text-end"&gt;
            &lt;input type="button" id="sendButton" value="Send Message" /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row p-1"&gt;
        &lt;div class="col-6"&gt;
            &lt;hr /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row p-1"&gt;
        &lt;div class="col-6"&gt;
            &lt;ul id="messagesList"&gt;&lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script src="signalr.js"&gt;&lt;/script&gt;
&lt;script src="chat.js"&gt;&lt;/script&gt;
</pre>
 
    <p>В директорията <b>/chat/wwwroot</b> създайте файл chat.js:</p>
        
<pre class='pre'>
'use strict';

var connection = new signalR.HubConnectionBuilder().withUrl('/chatHub').build();

//Disable the send button until connection is established.
document.getElementById('sendButton').disabled = true;

connection.on('ReceiveMessage', function (user, message) {
    var li = document.createElement('li');
    document.getElementById('messagesList').appendChild(li);
    // We can assign user-supplied strings to an element's textContent because it
    // is not interpreted as markup. If you're assigning in any other way, you 
    // should be aware of possible script injection concerns.
    li.textContent = `${user} says ${message}`;
});

connection.start().then(function () {
    document.getElementById('sendButton').disabled = false;
}).catch(function (err) {
    return console.error(err.toString());
});

document.getElementById('sendButton').addEventListener('click', function (event) {
    var user = document.getElementById('userInput').value;
    var message = document.getElementById('messageInput').value;
    connection.invoke('SendMessage', user, message).catch(function (err) {
        return console.error(err.toString());
    });
    event.preventDefault();
});
</pre>  

    <p>В директорията <b>/chat</b> създайте файл chatHub.cs:</p>

<pre class='pre'>
using Microsoft.AspNetCore.SignalR;

namespace SignalRChat.Hubs
{
    public class ChatHub : Hub
    {
        public async Task SendMessage(string user, string message)
        {
            await Clients.All.SendAsync("ReceiveMessage", user, message);
        }
    }
}
</pre> 

    <p>В Program.cs, добавете следните редове /+++++/</p>

<pre class='pre'>        
using SignalRChat.Hubs; // +++++

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorPages();
builder.Services.AddSignalR();   // +++++

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapRazorPages();

app.MapHub&lt;ChatHub&gt;("/chatHub"); // +++++

app.Run();
</pre>

    <p> В терминал:</p>       
        
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank/chat $ dotnet run
</pre>        

<hr>       
        
    <p> 3. Направете следната таблица на HTML /използвайте HTML атрибутите на тага TABLE <b>rowspan</b> и <b>colspan</b>/ 
    във статичен файл table.html на локалния компютър с Notepad приложението на Windows /или друг текстови редактор/ :</p>
    <p><img src='../img/image016.jpg' class='img narrow' alt='HTML Table'></p>
    
    <p>Примерно, започнете така:</p>
        
<pre class='pre'>
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
  &lt;head&gt; &lt;/head&gt;
  &lt;body&gt;
  
    &lt;table&gt;
      &lt;!-- your code here ... --&gt;
    &lt;/table&gt;
  
  &lt;/body&gt;
&lt;/html&gt;
</pre>        
   
    <p> 4. <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/razor-pages/?view=aspnetcore-7.0" target='_blank' class='lnk'>tutorial 
      razor pages</a> </p>
    
    <hr>
    
    <p> 5. <a href="https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/intro" target='_blank' class='lnk'>blazor - tutorial - 
      intro</a> </p>
    
    <hr>
    
    <h2 id='IX'>IX. Бази Данни × SQL</h2>
    <p><b>Бази данни (DB) и системи за управление на бази данни (DBMS)</b></p>
    <p><b>Стъпки в проектирането на база данни</b></p>
    <p>Ето стъпките в процеса на проектиране на база данни. Всяка стъпка
        е разгледана по-подробно в останалите раздели на този документ.</p>
    <p><b>Първа стъпка</b>: Определете целта на вашата база данни. Това
        ще ви помогне да решите кои и какви данни искате да съхранявате.</p>
    <p><b>Стъпка втора</b>: Определете таблиците, от които се нуждаете.
        След като имате ясна цел за вашата база данни, можете да разделите
        информацията си на отделни <b>обекти</b>, като например „<b>Служители</b>“
        или „<b>Поръчки</b>“. Всеки <b>обект</b> ще бъде таблица във
        вашата база данни.</p>
    <p><b>Стъпка трета</b>: Определете <b>полетата</b> /колоните/, от
        които се нуждаете. Решете каква информация искате да запазите
        във всяка таблица. Всяка категория информация в таблица се
        нарича <b>поле</b> и се показва като колона в таблицата. Например,
        едно поле в таблица <b>Служители</b> може да бъде <b>Фамилия</b>;
        друга може да бъде <b>Дата на наемане на служителя</b>.</p>
    <p><b>Четвърта стъпка</b>: Определете <b>връзките</b> /релациите/
        между отделните обекти. Разгледайте всяка таблица и решете
        как данните в една таблица са свързани с данните в други таблици.
        Добавете полета към таблиците или създайте нови таблици, за
        да изясните връзките, ако е необходимо.</p>
    <p><b>Стъпка пета</b>: Усъвършенствайте дизайна си. Анализирайте дизайна
        си за грешки. Създайте таблиците и добавете няколко записа
        с примерни данни. Вижте дали можете да получите желаните резултати
        от вашите таблици. Направете корекции на дизайна, ако е необходимо.</p>
    <p><b>Основи на нормализиацията на базите данни</b></p>
    <p>Тази статия обяснява терминологията на нормализазията на базите
        данни за начинаещи. Основното разбиране на тази терминология
        е полезно, когато обсъждаме дизайна на релационна база данни.</p>
    <p><b>Описание на нормализацията</b></p>
    <p>Нормализацията е процес на организиране на данните в база данни.
        Това включва създаване на таблици и установяване на връзки
        между тези таблици съгласно правила, предназначени както за
        защита на данните, така и за по-гъвкава база данни чрез елиминиране
        на излишъка и непоследователните зависимостти между данните.</p>
    <p>Излишните данни заемат излишно дисково пространство и създават
        проблеми с поддръжката. Ако данни, които съществуват на повече
        от едно място, трябва да бъдат променени, то данните трябва
        да бъдат променени по абсолютно същия начин на всички места,
        където ги има. Промяната на <b>Адреса</b> на клиента е много
        по-лесна за изпълнение, ако тези данни се съхраняват само в
        таблицата <b>Клиенти</b> и никъде другаде в базата данни.</p>
    <p>Какво е "непоследователна зависимост"? Въпреки че е интуитивно
        за потребителя да търси в таблицата Клиенти адреса на конкретен
        клиент, може да няма смисъл да търси там заплатата на служителя,
        който се обажда на този клиент. Заплатата на служителя е свързана
        със /или зависи от/ служителя и следователно трябва да бъде
        преместена в таблицата <b>Служители</b>. Непоследователните
        зависимости могат да затруднят достъпа до данните, тъй като
        пътят за намиране на данните може да липсва или да е повреден.</p>
    <p>Има няколко правила за нормализиране на базата данни. Всяко правило
        се нарича "нормална форма". Ако се спазва първото
        правило, се казва, че базата данни е в „първа нормална форма“.
        Ако се спазват първите три правила, се счита, че базата данни
        е в „трета нормална форма“. Въпреки че са възможни други нива
        на нормализация, третата нормална форма се счита за най-високото
        ниво, необходимо за повечето приложения.</p>
    <p>Както при много официални правила и спецификации, реалните сценарии
        не винаги позволяват перфектно съответствие. По принцип нормализацията
        изисква допълнителни таблици и някои разработчици намират това
        за тромаво. Ако решите да нарушите едно от първите три правила
        за нормализиране, уверете се, че вашето приложение предвижда
        всички проблеми, които могат да възникнат, като дублирани данни
        и непоследователни зависимости.</p>
    <p><b>Първа нормална форма</b></p>
    <p>•Елиминирайте повтарящите се групи в отделните таблици.</p>
    <p>•Създайте отделна таблица за всеки набор от свързани данни.</p>
    <p>•Идентифицирайте всеки набор от свързани данни с първичен ключ.</p>
    <p>Не използвайте множество полета в една таблица за съхраняване на
        подобни данни. Например, за проследяване на артикул от инвентара,
        който може да идва от два възможни източника, записът на инвентара
        може да съдържа полета за <b>Код на доставчик 1</b> и <b>Код на доставчик 2</b>. </p>
    <p>Какво се случва, когато добавите трети доставчик? Добавянето на
        поле не е отговорът; той изисква модификации на програмата
        и таблицата и не побира гладко динамичен брой доставчици. Вместо
        това поставете цялата информация за доставчици в отделна таблица,
        наречена Доставчици, след което свържете инвентара към доставчиците
        с ключ за номер на артикул или доставчиците към инвентара с
        ключ за код на доставчик.</p>
    <p><b>Втора нормална форма</b></p>
    <p>•Създайте отделни таблици за набори от стойности, които се прилагат
        към множество записи.</p>
    <p>•Свържете тези таблици с външен ключ.</p>
    <p>Записите не трябва да зависят от нищо друго освен от първичния
        ключ на таблицата (съставен ключ, ако е необходимо). Например,
        разгледайте адреса на клиент в счетоводна система. Адресът
        е необходим за таблицата Клиенти, но също и за таблиците Поръчки,
        Доставка, Фактури, Вземания и Колекции. Вместо да съхранявате
        адреса на клиента като отделен запис във всяка от тези таблици,
        запазете го на едно място или в таблицата Клиенти, или в отделна
        таблица Адреси.</p>
    <p><b>Трета нормална форма</b></p>
    <p>•Елиминирайте полетата, които не зависят от ключа.</p>
    <p>Стойностите в запис, които не са част от ключа на този запис, не
        принадлежат към таблицата. Като цяло, всеки път, когато съдържанието
        на група от полета може да се отнася за повече от един запис
        в таблицата, обмислете поставянето на тези полета в отделна
        таблица.</p>
    <p>Например в таблица за набиране на служители името и адресът на
        университета на кандидата може да бъдат включени. Но имате
        нужда от пълен списък с университети за групови писма. Ако
        информацията за университета се съхранява в таблицата с кандидати,
        няма начин да се изброят университети без настоящи кандидати.
        Създайте отделна таблица с университети и я свържете с таблицата
        с кандидати с ключ на кода на университета.</p>
    <p><b>ИЗКЛЮЧЕНИЕ</b>: Придържането към третата нормална форма, макар
        и теоретично желателно, не винаги е практично. Ако имате таблица
        Клиенти и искате да елиминирате всички възможни зависимости
        между полета, трябва да създадете отделни таблици за градове,
        пощенски кодове, търговски представители, класове клиенти и
        всеки друг фактор, който може да се дублира в множество записи.
        На теория подобно нормализиране си заслужава да се преследва.
        Много малки таблици обаче могат да влошат производителността
        или да надхвърлят капацитета на отворения файл и паметта.</p>
    <p>Може да е по-осъществимо да се приложи трета нормална форма само
        към данни, които се променят често. Ако някои зависими полета
        останат, проектирайте приложението си така, че да изисква потребителят
        да проверява всички свързани полета, когато някое от тях бъде
        променено.</p>
    <p><b>Други нормални форми</b></p>
    <p>Четвъртата нормална форма, наричана още нормална форма на Бойс
        Код (BCNF), и петата нормална форма съществуват, но рядко се
        разглеждат в практическия дизайн. Пренебрегването на тези правила
        може да доведе до по-малко от перфектния дизайн на базата данни,
        но не трябва да засяга функционалността.</p>
    <p><b>Нормализиране на примерна таблица</b></p>
    <p>Тези стъпки демонстрират процеса на нормализиране на фиктивна студентска
        таблица.</p>
    <p>0. <b>Ненормализирана таблица</b>:</p>
    
    <table>
      <thead>
        <tr><th>Student#</th><th>Advisor</th><th>Adv-Room</th><th><span class='red'>Class1</span></th><th><span class='red'>Class2</span></th><th><span class='red'>Class3</span></th></tr>
      </thead>  
      <tbody>
        <tr><td>1022</td><td>Jones</td><td>412</td><td>101-07</td><td>143-01</td><td>159-02</td></tr>
        <tr><td>4123</td><td>Smith</td><td>216</td><td>101-07</td><td>143-01</td><td>179-04</td></tr>
      </tbody>  
    </table>
    
    <p>1. <b>Първа нормална форма</b>: Без повтарящи се групи 
    /Колони, които съдържат едно и също, т.е. без повторения във хоризонтала/ </p>
    <p>Таблиците трябва да имат само две измерения. Тъй като един студент
        участва в няколко класа, тези класове трябва да бъдат изброени
        в отделна таблица. Полетата <b>Class1</b>, <b>Class2 </b>и
        <b>Class3 </b>в горните записи са индикации за проблем с дизайна.</p>
    <p>Електронните таблици /като Excel/ често използват трето измерение,
        но таблиците в базите данни не трябва. Друг начин да разгледате
        този проблем е с релация "един към много", не поставяйте
        страната на едния, и страната на многото в една и съща таблица.
        Вместо това създайте друга таблица в първата нормална форма,
        като елиминирате повтарящата се група (<b>Class#</b>), както
        е показано по-долу:</p>
    <table>
      <thead>  
        <tr>
            <th>Student#</th>
            <th>Advisor</th>
            <th>Adv-Room</th>
            <th>Class#</th>
        </tr>
      </thead>
      <tbody>  
        <tr><td>1022</td><td>Jones</td><td>412</td><td><b><span class='red'>101-07</span></b></td></tr>
        <tr><td>1022</td><td>Jones</td><td>412</td><td><b><span class='lil'>143-01</span></b></td></tr>
        <tr><td>1022</td><td>Jones</td><td>412</td><td>159-02</td></tr>
        <tr><td>4123</td><td>Smith</td><td>216</td><td><b><span class='red'>101-07</span></b></td></tr>
        <tr><td>4123</td><td>Smith</td><td>216</td><td><b><span class='lil'>143-01</span></b></td></tr>
        <tr><td>4123</td><td>Smith</td><td>216</td><td>179-04</td></tr>
      </tbody>  
    </table>
    <p><b>2. Втора нормална форма</b>: Елиминирайте излишните данни /без повторения във вертикала, 
    т.е. в дедена колона да няма 2 еднакви записа/</p>
    <p>Обърнете внимание на множеството стойности на <b>Class#</b> за
        всяка стойност на <b>Student#</b> в горната таблица. <b>Class#</b>
        не е функционално зависим от <b>Student#</b> (първичен ключ),
        така че тази връзка не е във втора нормална форма.</p>
    <p>Следните таблици демонстрират втората нормална форма:</p>
    <p><b>Таблица Студенти</b>:</p>
    
    <table>
      <thead>
        <tr><th>Student#</th><th>Advisor</th><th>Adv-Room</th></tr>
      </thead>
      <tbody>  
        <tr><td>1022</td><td><b><span class='lil'>Jones</span></b></td><td><b><span class='lil'>412</span></b></td></tr>
        <tr><td>4123</td><td><b><span class='ora'>Smith</span></b></td><td><b><span class='ora'>216</span></b></td></tr>
      </tbody>  
    </table>
    
    <p><b>Таблица Регистрации /Релация много-към-много/</b></p>
    <table>
      <thead>
        <tr><th>Student#</th><th>Class#</th></tr>
      </thead>
      <tbody>  
        <tr><td>1022</td><td>101-07</td></tr>
        <tr><td>1022</td><td>143-01</td></tr>
        <tr><td>1022</td><td>159-02</td></tr>
        <tr><td>4123</td><td>101-07</td></tr>
        <tr><td>4123</td><td>143-01</td></tr>
        <tr><td>4123</td><td>179-04</td></tr>
      </tbody>  
    </table>
    
    <p><b>3. Трета нормална форма</b>: Елиминиране на данни, които не зависят от ключа</p>
    <p>В горния пример <b>Adv-Room</b> (номерът на офиса на преподавателя)
        е функционално зависим от атрибута <b>Advisor</b>. Решението
        е да преместите този атрибут от таблицата <b>Students</b> в
        таблицата <b>Faculty</b>, както е показано по-долу:</p>
    <p><b>Таблица Студенти</b></p>
    <table>
      <thead>
        <tr><th>Student#</th><th>Advisor</th></tr>
      </thead>
      <tbody>  
        <tr><td>1022</td><td>Jones</td></tr>
        <tr><td>4123</td><td>Smith</td></tr>
      </tbody>  
    </table>
    
    <p><b>Таблица Регистрации</b></p>
    <table>
      <thead>
        <tr><th>Student#</th><th>Class#</th></tr>
      </thead>
      <tbody>  
        <tr><td>1022</td><td>101-07</td></tr>
        <tr><td>1022</td><td>143-01</td></tr>
        <tr><td>1022</td><td>159-02</td></tr>
        <tr><td>4123</td><td>101-07</td></tr>
        <tr><td>4123</td><td>143-01</td></tr>
        <tr><td>4123</td><td>179-04</td></tr>
      </tbody>  
    </table>
    
    <p><b>Таблица Факултети</b></p>
    
    <table>
      <thead>
        <tr><th>Name</th><th>Room</th><th>Dept</th></tr>
      </thead>  
      <tbody>  
        <tr><td>Jones</td><td>412</td><td>42</td></tr>
        <tr><td>Smith</td><td>216</td><td>42</td></tr>
      </tbody>  
    </table>
    
    <hr>
        
    <p><b>Основи на SQL</b></p>
    <p>SQL /Structured Query Language/ е език за програмиране със специално
        предназначение, предназначен за управление на данни, съхранявани
        в система за управление на релационни бази данни (RDBMS), или
        за поточна обработка в система за управление на релационни
        потоци от данни ( RDSMS). </p>
    <p><b>Типове данни</b></p>
    <p>Всяка колона в дадена SQL таблица има типа на данните, които тази
        колона може да съдържа. ANSI SQL включва следните типове данни.[25]</p>
    <p>• Символен низ - VARCHAR(<b>n</b>): низ с променлива ширина с максимален
        размер от <b>n</b> знака; например: "Низ това е низ";
        "Hold my beer"; и други;</p>
    <p>• <b>Числа</b>: <b>INTEGER - </b>цяло число /25; 320; -3117; ...
        / или <b>DOUBLE PRECISION</b> - дробно число /3.14; 2.73; -1348.6755;  ... /</p>
    <p>• Дата и час: <b>TIMESTAMP - </b>например: '5-25-2023'; '14-01-2014';
        ...</p>
    <p><b>Създаване на таблици</b></p>
    <p><b>Дефиниране на данни</b> Езикът за дефиниране на данни (<b>DDL</b>)
        управлява структурата на таблицата и индекса. Основните команди
        на DDL са инструкциите <b>CREATE</b>, <b>ALTER</b> и <b>DROP</b>:</p>
    <p><b>CREATE </b>създава обект (например таблица) в базата данни,
        напр.:</p>

<pre class='pre'>
CREATE TABLE Faculty(
    Name VARCHAR(50),
    Room INTEGER,
    Dept INTEGER
);
</pre>

    <p><b>ALTER</b> променя структурата на съществуващ обект по различни
        начини, например добавяне на колона към съществуваща таблица,
        напр.:</p>

<pre class='pre'>
ALTER TABLE Faculty ADD AdvRoom INTEGER;
</pre>

    <p><b>DROP</b> изтрива обект в базата данни, обикновено безвъзвратно,
        т.е. не може да бъде възстановен, напр.:</p>

<pre class='pre'>
DROP TABLE Faculty;
</pre>
    <p><b>Вмъкване на данни в таблици - Data Manipulation Language</b></p>
    <p><b>Манипулиране на данни</b></p>
    <p>Езикът за манипулиране на данни (<b>DML</b>) е подмножеството на
        SQL, използвано за добавяне, актуализиране и изтриване на данни:</p>
<pre class='pre'>
INSERT INTO Faculty (Advisor, AdvRoom, Dept)
VALUES ('Jones', 412, 42);
</pre>

    <p>Вмъква нов запис (<b>ред</b>) в таблицата <b>Факултет</b>.</p>
    <p><b>Актуализиране на таблици</b></p>
    <p>UPDATE променя набор от съществуващи редове на таблица, напр.:</p>

<pre class='pre'>
UPDATE Faculty SET Advisor='James Jones' WHERE AdvRoom=412;
</pre>

    <p>Актуализира таблицата Faculty, като установява стойността на клетките
        в колоната Advisor на „James Jones“, на всички редове, които
        имат стойност <b>412</b> в колоната <b>AdvRoom. </b></p>
    <p><b>Извличане на данни от таблици на БД</b></p>
    <p><b>Queries - заявки</b></p>
    <p>Най-често срещаната операция в SQL е <b>заявката</b>, която се
        изпълнява с декларативния оператор <b>SELECT</b>. <b>SELECT</b>
        извлича данни от една или повече таблици или изрази. Стандартните
        оператори <b>SELECT</b> нямат постоянни ефекти върху базата
        данни.</p>
    <p>Заявките позволяват на потребителя да описва желаните данни, оставяйки
        системата за управление на база данни (СУБД) отговорна за планирането,
        оптимизирането и извършването на физическите операции, необходими
        за получаване на този резултат, който е описан от заявката.</p>
    <p>Заявката включва списък с колони за включване в крайния резултат,
        непосредствено след ключовата дума <b>SELECT</b>. Звездичка
        ("<b>*</b>") може също да се използва, за да се укаже,
        че заявката трябва да върне всички колони на заявените таблици.
        SELECT е най-сложният израз в SQL, с незадължителни ключови
        думи и клаузи, които включват:</p>
    <p>• Клаузата <b>FROM</b>, която указва таблицата(ите), от която да
        се извличат данни. Клаузата FROM може да включва незадължителни
        подклаузи <b>JOIN </b>за указване на правилата за свързване
        на таблици.</p>
    <p>• Клаузата <b>WHERE</b> включва <b>предикат</b> /клауза/ за сравнение,
        който ограничава редовете, върнати от заявката. Клаузата WHERE
        елиминира всички редове от набора с резултати, където предикатът
        за сравнение не се оценява на <b>True</b>.</p>
    <p>• Клаузата <b>GROUP BY</b> се използва за проектиране на редове
        с общи стойности в по-малък набор от редове. GROUP BY често
        се използва във връзка с функциите за агрегиране на SQL /<b>SUM</b>
        - сума; <b>AVERAGE</b> - средно аритметично/ или за премахване
        на дублиращи се редове от набор от резултати. Клаузата WHERE
        се прилага преди клаузата GROUP BY.</p>
    <p>• Клаузата <b>HAVING</b> включва предикат, използван за филтриране
        на редове, когато се използва и клаузата <b>GROUP BY</b>. Тъй
        като действа върху резултатите от клаузата GROUP BY, функциите
        за агрегиране могат да се използват в предиката на клаузата
        HAVING /например: SELECT ... HAVING SUM(PRICE) &gt; 20 /.</p>
    <p>• Клаузата <b>ORDER BY</b> идентифицира кои колони да използвате
        за сортиране на получените данни и в каква посока да ги сортирате
        (възходящо - <b>ASC</b> или низходящо - <b>DESC</b>). Без клауза
        ORDER BY, подредбата на редовете, върнат от SQL заявка, е недефиниран.</p>
    <p>Следното е пример за заявка SELECT, която връща списък с учители
        в 42 департамент от таблицата <b>Факултети</b>. Заявката извлича
        всички редове от таблицата <b>Faculty</b>, в която колоната
        <b>Dept</b> съдържа стойност, равна на <b>42</b>. Резултатът
        се сортира във възходящ ред по име на <b>Advisor</b>. Звездичката
        (<b>*</b>) в списъка за избор показва, че всички колони от
        таблицата на факултета трябва да бъдат включени в набора с
        резултати.</p>

<pre class='pre'>
SELECT   * 
FROM     Faculty 
WHERE    Dept = 42 
ORDER BY Advisor
</pre>

    <p>Резултата от заявката е следната таблица:</p>
    <table>
      <thead>
        <tr><th>Advisor</th><th>AdvRoom</th><th>Dept</th></tr>
      </thead>
      <tbody>  
        <tr><td>Jones</td><td>412</td><td>42</td></tr>
        <tr><td>Smith</td><td>216</td><td>42</td></tr>
      </tbody>  
    </table>
    
    <p><b>WHERE</b> Предикати<b> in; between; like; null; exists</b></p>
    
    <p>Тези предикати се използват най-вече в клаузата <b>WHERE</b> и
        включват:</p>
    <table>
      <thead>
        <tr><th>Оператор</th><th>Описание</th><th>Пример</th></tr>
      </thead>  
      <tbody>
        <tr><td>=</td><td>Равно на</td><td>WHERE Author = 'Alcott'</td></tr>
        <tr><td>&lt;&gt;&nbsp;</td><td>Различно (много DBMS приемат <b>!=</b> в добавка на<b>&lt;&gt;</b>)</td>
            <td>WHERE Dept &lt;&gt; 'Sales'</td></tr>
        <tr><td>&gt;&nbsp;</td><td>По-голямо от</td><td>WHERE Hire_Date &gt; '2012-01-31'</td></tr>
        <tr><td>&lt;&nbsp;</td><td>По-малко от</td><td>WHERE Bonus &lt; 50000.00</td></tr>
        <tr><td>&gt;=</td><td>По-голямо или равно</td><td>WHERE Dependents &gt;= 2</td></tr>
        <tr><td>&lt;=</td><td>По-малко или равно</td><td>WHERE Rate &lt;= 0.05</td></tr>
        <tr><td>BETWEEN</td><td>Между 2 стойности, включително</td><td>WHERE Cost BETWEEN 100.00 AND 500.00</td></tr>
        <tr><td>LIKE</td><td>Дали символен низ съвпада с друг</td><td>WHERE First_Name LIKE 'Will%'</td></tr>
        <tr><td>IN</td><td>Рано на една от няколко възможни изброени стойности</td><td>WHERE DeptCode IN (101, 103, 209)</td></tr>
        <tr><td>IS / IS NOT</td><td>Сравнява с NULL (липсващи данни)</td><td>WHERE Address IS NOT NULL</td></tr>
        <tr><td>IS NOT DISTINCT FROM</td><td>Дали е равно на стойност, или и двете са със съойност NULL (липсващи данни)</td>
            <td>WHERE Debt IS NOT DISTINCT FROM - Receivables</td></tr>
        <tr><td>AS</td><td>Промяна на името на полето /колоната/ в получения резултат</td><td>SELECT employee AS 'department1'</td></tr>
        <tr><td>UNION и UNION ALL</td><td>Снажда две таблици, от SQL1 и SQL2, като добавя таблицата от SQL2 след таблицата ot SQL1. 
               SQL1 и SQL2 трябва да връщат еднакъв брой колони</td><td>SELECT_SQL1 UNION/UNION ALL SELECT_SQL2</td></tr>            
      </tbody>  
    </table>
    
    <p><b>Забелжка за LIKE: LIKE </b>може да се ползва с <b>%</b> или с <b>*</b>. </p>
    <p>• * означава, че ще бъдат извлеччени резултати с всеки еденичен
        знак на мястото на <b>*</b>-та /например SELECT ... LIKE "Joh<b>*</b>"
        ➜ връща записи, които съдържат "Joh<b>n" , </b>но
        <b>не</b> "Joh<b>anson",</b> <b>нито "</b>Joh"
        /;  </p>
    <p>• % - ще бъдат извлечени резултати с всички множествени знаци на
        мястото на <b>%</b>-та /например SELECT ... LIKE "Joh%"
        ➜ връща записи, които съдържат и "Joh<b>n" </b>и
        "Joh<b>anson"</b> и "Joh" /. </p>
    
    <p><b>Клаузата OR или AND</b> е логически оператор в SQL, който ви позволява да комбинирате множество условия. 
      Обикновено се използва в клаузата WHERE, за да се укаже, че даден ред трябва да бъде включен в набора от 
      резултати, ако поне едно от условията WHERE е оценено като true.</p>
          
<pre class='pre'>
SELECT * FROM table_name WHERE condition1 OR/AND condition2;
</pre>
    
    <p>Моля, обърнете внимание, че клаузата OR/AND може да се използва в различни клаузи на SQL, като WHERE, 
      HAVING, JOIN, LIKE, CASE, EXISTS и в комбинация с операторите UNION и UNION ALL за комбиниране на 
      резултатите от заявката.</p>            
        
    <p><b>COALESCE </b>При LIKE може да се използва и така наречерната
        колация /collations/, които правят възможно сравняването на
        низове с различна големина на буквите - наприомер <b>J</b>ohn
        със <b>j</b>ohn. Те могат да бъдат реализирани чрез клаузата
        <b>COALESCE, </b>или по друг начин в зависимост от конретната
        СУБД.</p>
    <p><b>Съединения /JOIN/</b></p>
    <p>Примерът по-долу демонстрира заявка за съединяване на множество
        таблици по релация /с клаузата <b>JOIN</b>/, като връща списък
        на всички регистрации и информация за съветници, свързани с
        всеки запис:</p>

<pre class='pre'>
SELECT   Registration.Student, Registration.Class,
         Students.Advisor,
         Faculty.AdvRoom, Faculty.Dept
FROM     Registration
JOIN     Students on Registration.Student = Students.Student
JOIN     Facuty on Facuty.Advisor = Students.Advisor
ORDER BY Registration.Student
</pre>

    <p>Примерения резултат може да прилича на следното:</p>
    <table>
      <thead>
        <tr><th><b>Student</b></th><th><b>Class</b></th><th><b>Advisor</b></th><th><b>AdvRoom</b></th><th><b>Dept</b></th></tr>
      </thead>
      <tbody>
        <tr><td>1022</td><td>101-07</td><td>Jones</td><td>412</td><td>42</td></tr>
        <tr><td>1022</td><td>143-01</td><td>Jones</td><td>412</td><td>42</td></tr>
        <tr><td>1022</td><td>159-02</td><td>Jones</td><td>412</td><td>42</td></tr>
        <tr><td>4123</td><td>201-01</td><td>Smith</td><td>216</td><td>42</td></tr>
        <tr><td>4123</td><td>211-02</td><td>Smith</td><td>216</td><td>42</td></tr>
        <tr><td>4123</td><td>214-01</td><td>Smith</td><td>216</td><td>42</td></tr>
      </tbody>  
    </table>
    <p>В SQL има няколко типа съединения, които ви позволяват да комбинирате
        данни от множество таблици въз основа на общи колони /<b>релации</b>/.
        Ето кратко обяснение на основните типове присъединявания:</p>
    <p>• <b>INNER JOIN</b>: Вътрешното съединение връща само редовете,
        които имат съвпадащи стойности в двете таблици. Той комбинира
        ред от едната таблица с ред от другата в нов ред в резултата
        на основа на определеното условие за свързване. Ако в заявката
        пише само <b>JOIN</b>, то това е <b>JOIN</b>-а който се изпълнява
        по подразбиране.</p>
    <p>• <b>LEFT JOIN</b>: Лявото съединение връща всички редове от лявата
        таблица и съответстващите редове от дясната таблица. Ако няма
        съвпадения, пак ще върне всички редове от лявата таблица и
        ще замени липсващите стойности с NULL. </p>
    <p>• <b>RIGHT JOIN:</b> Дясното съединение е подобно на лявото съединение,
        но връща всички редове от дясната таблица и съответстващите
        редове от лявата таблица. Ако няма съвпадения, той пак ще върне
        всички редове от дясната таблица и ще замени липсващите стойности
        с NULL. </p>
    <p>• <b>FULL JOIN</b>: Пълното обединяване, известно още като пълно
        външно обединяване, връща всички редове както от лявата, така
        и от дясната таблица. Ако има съвпадащи редове, той ги комбинира
        в един ред. Ако няма съвпадения, включва NULL стойности за
        колоните от несъвпадащата таблица.</p>
    <p>• <b>CROSS JOIN</b>:Кръстосаното съединение, известно още като
        Декартово съединение / Cartesian join/, връща декартовото произведение
        на двете таблици, т.е. всички възможни комбинации от редове
        от двете таблици. </p>
    <p>Това са основните типове съединения в SQL, които ви позволяват
        да комбинирате данни от множество таблици въз основа на различни
        условия.</p>
    <p><b>Функции</b></p>
    <p>SQL е предназначен за конкретна цел: да прави заявки върху данни,
        съдържащи се в релационна база данни. SQL е базиран на множествен,
        декларативен език за заявки, а не е императивен език като C
        или BASIC. Въпреки това, разширенията към стандартния SQL добавят
        функционалност с която може да се добави потребителска функция
        /<b>Stored Procedures</b>/, или изгледи на данни /<b>View</b>/.
        </p>
    <hr>
    <p><b>Задачи Бази данни</b></p>
    <p>В Codespaces / Terminal:</p>
    <p>1. Създаване на <b>база данни </b>в директория <b>sql</b>:</p>
    <p>@404joe ➜ /workspaces/codespaces-blank $ <b>mkdir sql</b></p>
    <p> @404joe ➜ /workspaces/codespaces-blank $ <b>cd sql</b></p>
    <p>Добавяне на <b>.NET</b> поддръжка за <b>SQLite :</b></p>
    <p>@404joe ➜ /workspaces/codespaces-blank/sql $ <b>dotnet add package system.data.sqlite</b></p>
    <p><b>Създаване на база данни и отварянето и</b></p>
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank/sql $ <b>sqlite3 </b>'students_db.db'
</pre> 
    <p>Изпълнете следните SQL команди:</p>  

<pre class='pre'>
/*<b>Създаване </b>на таблица <b>Students</b>*/
CREATE TABLE Students (
  StudentID INTEGER,
  Advisor   TEXT
);

/*<b>Създаване на записи </b>за студенти в таблица  <b>Students </b>*/
INSERT INTO Students (StudentID, Advisor)
VALUES
  (1022,'Jones'),
  (4123,'Smith');

/*<b>Създаване </b>на таблица <b>Faculty</b>*/
CREATE TABLE Faculty (
  Name TEXT,
  Room INTEGER,
  Dept INTEGER
);

/*<b>Създаване на записи </b>в таблица  <b>Faculty </b>*/
INSERT INTO Faculty (Name, Room, Dept)
VALUES
  ('Jones', 412, 42),
  ('Smith', 216, 42);

/*<b>Създаване </b>на таблица <b>Registration</b>*/
CREATE TABLE Registration (
  StudentID INTEGER,
  ClassID   TEXT
);

/*<b>Създаване на записи </b>в таблица  <b>Registration </b>*/
INSERT INTO Registration (StudentID, ClassID)
VALUES
  (1022,'101-07'),
  (1022,'143-01'),
  (1022,'159-02'),
  (4123,'101-07'),
  (4123,'143-01'),
  (4123,'179-04');
</pre>

<p><b>Заявка за извличане </b>на всички данни /с имена на клони - <span class='blu'>headers</span>, и табличен вид - <span class='grn'>column</span>/ :</p>

<pre class='pre'>
<span class='blu'>.headers ON</span>
<span class='grn'>.mode column</span>

SELECT   Registration.StudentID, Registration.ClassID,
         Students.Advisor,
         Faculty.Room, Faculty.Dept
FROM     Registration
JOIN     Students on Registration.StudentID = Students.StudentID
JOIN     Faculty on Faculty.Name = Students.Advisor
ORDER BY Registration.StudentID
</pre>

    <p>Резултат:</p>
    <p><img src='../img/image005.jpg' class='img' alt='SQL Result'></p>
    <p><b>.quit</b> за изход от <b>sqlite3</b></p>
    
    <hr>
    
    <p>Задачи</p>
    
    <p><b>3. Извличане на записи от SQLite БД в C# програма</b></p>
    <p><b>NuGet install:</b></p>
        
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank $ <b>mkdir sql_console  </b>
@404joe ➜ /workspaces/codespaces-blank $ <b>cd sql_console </b>            
@404joe ➜ /workspaces/codespaces-blank/sql_console $ <b>dotnet new console</b>
@404joe ➜ /workspaces/codespaces-blank/sql_console $ <b>dotnet add package system.data.sqlite</b>
</pre>


    <p><b>Заместете</b> съдържанието на файла Program.cs със следното</p>
        
<pre class='pre'>
using System;
using System.Data.SQLite;
string connectionString = "Data Source=../sql/students_db.db";

using (SQLiteConnection connection = new SQLiteConnection(connectionString))
{
    connection.Open();
    // Изпълняване на SELECT SQL заявка, и обработка на резултата
    // Знака     @ поставен "пред символен низ показва, 
    //             че низа се пренася на няколко реда: до следващата кавичка "

    string sql = @" SELECT   Registration.StudentID, Registration.ClassID, 
                             Students.Advisor, Faculty.Room, Faculty.Dept
                    FROM     Registration
                    JOIN     Students on Registration.StudentID = Students.StudentID
                    JOIN     Faculty on Faculty.Name = Students.Advisor
                    ORDER BY Registration.StudentID ; ";
                    
    using (SQLiteCommand command = new SQLiteCommand(sql, connection))
    {
        using (SQLiteDataReader reader = command.ExecuteReader())
        {
            while (reader.Read())
            {
                // Access the result values using reader["column_name"]
                var column1Value = reader["Advisor"];
    
                var column2Value = reader["Room"];  
    
                // Process the data as needed
                Console.WriteLine($"{column1Value} | {column2Value} ");
            }
        }
    }
}
</pre>

    <hr>
    
    <h2 id='X'>X. C# WebApp × SQL Бази Данни</h2>
    
    
    <p><b>WEBAPP × RAZOR PAGES /SSR/</b></p>        
    
    <p>Идеята на следното занимание е да изпълним заявка към базата със SQL SELECT който връща таблица, 
    да вземем тази таблица, и да генерираме от нея HTML код на таблица /HTML тагове/, която да 
    върнем на посетителя, като готов HTML /приготвен на сървъра и върнат на клиента/. Това е познато 
    като <b>SSR</b> - Рендерирането от страна на сървъра. 
    За целата в <b>Pages/index.cshtml.cs</b> трябва да се добави 
    1. Заявка към базата, която връща резултат; 2. Да попълним 2 масива - Cols - имената на 
    колоните - едномерен, и Rows - съдържанието на самата таблица - двумерен, и двата от тип 
    символен низ /string/. След това те /Cols и Rows/ ще могат да се използват в HTML шаблона
    на страницата, при неговото рендериране /генериране/ на WEB сървъра. 
    Ако се направи GET заявка от Web браузъра към някакъв адрес,
    например, https://www.somehost.com/ , то WEB сървъра на този хост по подразбиране връща
    файла index.html . Ако заявката обаче е към https://www.somehost.com/Privacy.html , то WEB 
    сървъра връща файла Privacy.html</p>        

<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank $ <b>mkdir sql_webapp</b>
@404joe ➜ /workspaces/codespaces-blank $ <b>cd sql_webapp</b>
@404joe ➜ /workspaces/codespaces-blank/sql_webapp $ <b>dotnet new webapp</b>
@404joe ➜ /workspaces/codespaces-blank/sql_webapp $ <b>dotnet add package Microsoft.Data.Sqlite</b>
</pre>
        
    <p>В <b>/sql_webapp/Pages/index.cshtml.cs</b> променте <b>:</b></p>

<pre class='pre'>
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.Data.Sqlite; // + добавете този ред
namespace sql_webapp.Pages;

public class IndexModel : PageModel
{
    public List&lt;string&gt; Cols { get; set; }  = new List&lt;string&gt;(); // да подадем към .cshtml
    public List&lt;List&lt;string&gt;&gt; Rows { get; set; }  = new List&lt;List&lt;string&gt;&gt;(); // да подадем към .cshtml
    
    public void <span class='red'>OnGet</span>() // OnGet метода се вика при заявка към index.html
    {
        // ++++ добавете следното
        string connectionString = "Data Source=../sql/students_db.db";
        using (var connection = new SqliteConnection(connectionString))
        {
            connection.Open();
            string sql = @" SELECT  Registration.StudentID, 
                            Registration.ClassID,  
                            Students.Advisor,
                            Faculty.Room, Faculty.Dept
                   FROM     Registration
                   JOIN     Students on Registration.StudentID = Students.StudentID
                   JOIN     Faculty on Faculty.Name = Students.Advisor
                   ORDER BY Registration.StudentID ; ";
                   
            using (var command = new SqliteCommand(sql, connection))
            {
                using (var reader = command.ExecuteReader())
                {
                    Cols = new List&lt;string&gt;();
                    Rows    = new List&lt;List&lt;string&gt;&gt;();
                    
                    // имена на колони
                    for (int i = 0; i &lt; reader.FieldCount; i++)
                    {
                        Cols.Add(reader.GetName(i));
                    }
                    
                    // редове
                    while (reader.Read())
                    {
                        var row = new List&lt;string&gt;();
                        for (int i = 0; i &lt; reader.FieldCount; i++)
                        {   //  ! ➜ null forgiving operator
                            row.Add(reader[i].ToString() ! ); 
                        }
                        Rows.Add(row);
                    }
                }
            }
        }         // до тук
    }      
}      
</pre>

        <p>В <b>/sql_webapp/Pages/index.cshtml</b> се намира HTML шаблона на 
           страницата, която ще бъде превърната в HTML, и върната при заявка от WEB browsera /В случая index.cshtml/. 
           Променливите Cols и Rows са достъпни при генериране на HTML таговете за таблица. Достъпват се чрез 
           <b>Model.Cols</b> и <b>Model.Rows</b> от .cshtml файла /HTML шаблона/. Използва се оператор 
           <span class='grn'>@foreach</span> за обхождане на двата масива.</p>
           
        <p>В <b>/sql_webapp/Pages/index.cshtml</b> най долу във файла добавете<b>:</b></p>
        
<pre class='pre'>
&lt;!-- ADD FOLLOWING LINES FOR SQLITE × RAZOR PAGES table tag DEMO --&gt;
&lt;table&gt;
    &lt;thead&gt;   &lt;!-- thead таг - table header --&gt;
        &lt;tr&gt;  &lt;!-- tr таг - table row       --&gt;
            <span class='grn'>@foreach (</span><span class='yel'>var column</span><span class='grn'> in <b>Model.Cols</b>)</span>
            { 
                &lt;!-- генериране на тагове th - table header --&gt;
                &lt;th&gt;<span class='yel'>@column</span>&lt;/th&gt;
            }
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;   &lt;!-- tbody таг - table body --&gt;
        <span class='grn'>@foreach (</span><span class='yel'>var row</span> <span class='grn'>in <b>Model.Rows</b>)</span>
        {
            &lt;tr&gt;
                <span class='blu'>@foreach (</span><span class='ora'>var value</span> <span class='blu'>in</span> <span class='yel'>row</span><span class='blu'>)</span>
                {
                    &lt;td&gt;<span class='ora'>@value</span>&lt;/td&gt;
                }
            &lt;/tr&gt;
        }
    &lt;/tbody&gt;
&lt;/table&gt;
</pre>

    <p>В Terminal<b>: dotnet run</b></p>
    
    <p>Генерирания HTML от: SQL заявката + данните в базата + и cshtml шаблона,
      който бива вграден във върнатата на WEB броузъра страница index.html
      изглежда по следния начин:</p>
        
<pre class='pre'>
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;StudentID&lt;/th&gt;
      &lt;th&gt;ClassID&lt;/th&gt;
      &lt;th&gt;Advisor&lt;/th&gt;
      &lt;th&gt;Room&lt;/th&gt;
      &lt;th&gt;Dept&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1022&lt;/td&gt;
      &lt;td&gt;101-07&lt;/td&gt;
      &lt;td&gt;Jones&lt;/td&gt;
      &lt;td&gt;412&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1022&lt;/td&gt;
      &lt;td&gt;143-01&lt;/td&gt;
      &lt;td&gt;Jones&lt;/td&gt;
      &lt;td&gt;412&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1022&lt;/td&gt;
      &lt;td&gt;159-02&lt;/td&gt;
      &lt;td&gt;Jones&lt;/td&gt;
      &lt;td&gt;412&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4123&lt;/td&gt;
      &lt;td&gt;101-07&lt;/td&gt;
      &lt;td&gt;Smith&lt;/td&gt;
      &lt;td&gt;216&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4123&lt;/td&gt;
      &lt;td&gt;143-01&lt;/td&gt;
      &lt;td&gt;Smith&lt;/td&gt;
      &lt;td&gt;216&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4123&lt;/td&gt;
      &lt;td&gt;179-04&lt;/td&gt;
      &lt;td&gt;Smith&lt;/td&gt;
      &lt;td&gt;216&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre>        
        
    <p>във WEB броузъра:</p>
    
    <p><img src="../img/image006.jpg" class='img' alt='Browse Result'></p>
    
    <p>Така и така горния пример стана доста дълъг, но можем да го усложним още малко.
    В файла <b>/sql_webapp/Pages/index.cshtml</b> променете тага за таблица : &lt;table&gt;,
    като добавите Bootstrap CSS class към таблицата по следния начин:</p>
    
<pre class='pre'>
&lt;table <span class='yel'>class='table'</span>&gt;
</pre>
    <p>Резултат:</p>
    <p><img src='../img/image014.jpg' class='img' alt='Bootstrap CSS'></p>
    <p>Предимствата на Bootstrap са че може наготово да използвате CSS стилове, като търсите тага
    върху който искате да приложите CSS стил в сайта на Bootstrap, и добавите класа към съответния таг,
    недостатък е че много трудно се променят някои малки аспекти от дадена CSS библиотека.</p>
    
    <hr>
     
    <p><b>WEBAPP × JSON × VUE.JS</b></p>
    
    <p>Рендерирането от страна на сървъра (SSR) /по-горе/ и AJAX с JSON и Vue.js /CSR/ са два 
    различни подхода за изграждане на уеб приложения.</p>
    
    <p><b>Рендериране от страна на сървъра (SSR):</b></p>
            
    <p>SSR е по-бавен за последващи първоначалното зареждане взаимодействия, тъй като изисква 
    двупосочно пътуване до сървъра и за всяко действие се генерират големи HTML документи.</p>
    
    <p><b>AJAX + JSON + Vue.js /CSR/</b></p>
    
    <p><b>CSR</b> /Client Side Rendering/, зарежда първоначалния HTML шаблон и 
    JavaScript от сървъра в броузера а след това използва <b>AJAX</b> (Асинхронен JavaScript 
    и XML) заявки за извличане на <b>JSON</b> данни от сървъра /чрез <b>JSON api Endpoint</b>/. 
    След това, вече във браузера, генерира HTML съдържание и го изобразява.</p>
    
    <p><b>JSON</b> данните се използват за динамично актуализиране на потребителския интерфейс.</p>
    
    <p><b>Vue.js</b> е популярна JavaScript платформа, която осигурява мощно обвързване 
    на данни и шаблони, и е базирана на преизползваеми компоненти.</p>
    
    <p><b>AJAX</b> заявките позволяват на приложението да извлича данни от сървъра асинхронно, 
    без да презарежда цялата страница.</p>
    
    <p>Основното предимство на този подход /CSR/ е по-интерактивно и отзивчиво потребителско изживяване, тъй като 
    приложението може да актуализира определени части от страницата без пълно ѝ презареждане. </p>
    
    <p>Мащабируемост: Чрез разтоварване на обработката на данни към клиента, CSR може да намали 
    натоварването на сървъра и да подобри мащабируемостта на приложението.</p>
    
    <p>Разделяне на проблемите: С CSR можете да разделите логиката за извличане и рендиране на данни, което 
    позволява по-чиста организация и поддръжка на кода.</p>
    
    
    <p><b>Api Endpoint</b> - Крайна точка за AJAX заявка; връща JSON символен низ, генериран на сървъра, като следния:</p>
        
<pre class='pre'>
[{"StudentID":1022,"ClassID":"101-07","Advisor":"Jones","Room":412,"Dept":42},
 {"StudentID":1022,"ClassID":"143-01","Advisor":"Jones","Room":412,"Dept":42},
 {"StudentID":1022,"ClassID":"159-02","Advisor":"Jones","Room":412,"Dept":42},
 {"StudentID":4123,"ClassID":"101-07","Advisor":"Smith","Room":216,"Dept":42},
 {"StudentID":4123,"ClassID":"143-01","Advisor":"Smith","Room":216,"Dept":42},
 {"StudentID":4123,"ClassID":"179-04","Advisor":"Smith","Room":216,"Dept":42}]
</pre>
        
        <p>Първо да създадем ново приложение:</p>
        
<pre class='pre'>
@404joe ➜ /workspaces/codespaces-blank $ <b>mkdir ajax</b>
@404joe ➜ /workspaces/codespaces-blank $ <b>cd ajax</b>
@404joe ➜ /workspaces/codespaces-blank/ajax $ <b>dotnet new web</b>
</pre>


    <p>В Program.cs добавете мапинг на JSON крайните точки /статичен файл 
       https://somehost.com/index.html и api endpoint 
       <span class='ora'>https://somehost.com/api/MyJSON</span> /:</p>
        
<pre class='pre'>
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

var app = builder.Build();

app.UseRouting();

// Map JSON api
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllers();
});

// Map  index.html 
app.UseDefaultFiles();
app.UseStaticFiles();

app.Run(async context =>
{
    await context.Response.SendFileAsync("index.html");
});

app.Run();
</pre>
 

    <p>Api Endpoint, достъпен в последствие на адрес: https://someserver.com<b><span class='ora'>/api/MyJSON</span></b>, 
      запишете следното във файла <b>/ajax/Pages/JSON.cs</b> </p> 
     

<pre class='pre'>
using Microsoft.AspNetCore.Mvc;
using System.Text.Json; 

namespace YourNamespace
{
    [ApiController]
    [Route("<span class='ora'>api</span>/[controller]")]
    public class <b><span class='ora'>MyJSON</span></b> : ControllerBase
    {
        [HttpGet]
        public IActionResult Get()
        {

            string jsonRes = // "" -> в C# се пише "", в браузера излиза " / " escaping /
                @"[{""StudentID"":1022,""ClassID"":""101-07"",""Advisor"":""Jones"",""Room"":412,""Dept"":42},
                   {""StudentID"":1022,""ClassID"":""143-01"",""Advisor"":""Jones"",""Room"":412,""Dept"":42},
                   {""StudentID"":1022,""ClassID"":""159-02"",""Advisor"":""Jones"",""Room"":412,""Dept"":42},
                   {""StudentID"":4123,""ClassID"":""101-07"",""Advisor"":""Smith"",""Room"":216,""Dept"":42},
                   {""StudentID"":4123,""ClassID"":""143-01"",""Advisor"":""Smith"",""Room"":216,""Dept"":42},
                   {""StudentID"":4123,""ClassID"":""179-04"",""Advisor"":""Smith"",""Room"":216,""Dept"":42}]";
                
            return Ok(jsonRes);  // Console.WriteLine(jsonRes);
        }
    }
}        
</pre>  

    <p>Резултат:</p>
    
    <p><img src="../img/image011.jpg" class='img' alt='JSON Result'></p>
    
    
    <p>Създайте файла /ajax/wwwroot/index.html добавете HTML Vue.js 
       шаблона + клиентския код, за заявка към JSON API endpoint /на 
       javascript + <span class='grn'>vue.js</span>/:</p>

<pre class='pre'>
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
  &lt;head&gt; &lt;/head&gt;

  &lt;body&gt;

    &lt;div <span class='grn'>v-scope</span> <span class='lil'>id='json_tbl_target'</span> <span class='grn'>@vue:</span><span class='red'>mounted='app.mounted'</span>&gt;
    
      &lt;button <span class='yel'>@click='app.search()'</span>&gt;Make AJAX Call&lt;/button&gt;
    
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;Student ID&lt;/th&gt;
            &lt;th&gt;Class ID&lt;/th&gt;
            &lt;th&gt;Advisor&lt;/th&gt;
            &lt;th&gt;Room&lt;/th&gt;
            &lt;th&gt;Dept&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          &lt;tr <span class='grn'>v-for='item in <span class='blu'>app.results</span>'</span>&gt;
            &lt;td&gt;<span class='grn'>{{ item.StudentID }}</span>&lt;/td&gt;
            &lt;td&gt;<span class='grn'>{{ item.ClassID }}</span>&lt;/td&gt;
            &lt;td&gt;<span class='grn'>{{ item.Advisor }}</span>&lt;/td&gt;
            &lt;td&gt;<span class='grn'>{{ item.Room }}</span>&lt;/td&gt;
            &lt;td&gt;<span class='grn'>{{ item.Dept }}</span>&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  
    &lt;script src='<span class='grn'>https://unpkg.com/petite-vue</span>'&gt;&lt;/script&gt;
  
    &lt;script&gt;
      const app = new <span class='grn'>PetiteVue.reactive({
        el: '</span><span class='lil'>#json_tbl_target</span><span class='grn'>',</span>
        <span class='blu'>results</span><span class='grn'>: '',</span>
        async <span class='yel'>search()</span> {
          const StudentsData = await fetch(<span class='ora'>'/api/MyJSON'</span>)
          <span class='grn'>this.</span><span class='blu'>results</span> = await StudentsData.json()
          console.log(this.results)
        },
      
        <span class='red'>mounted</span>() {
          console.log('mounted')
          <span class='grn'>this.</span><span class='yel'>search()</span>
        }
      <span class='grn'>});</span>
    
      <span class='grn'>PetiteVue.createApp({app}).</span><span class='red'>mount</span>('<span class='lil'>#json_tbl_target</span><span class='grn'>') </span>
    &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Резултат:</p>
    
    <p><img src="../img/image012.jpg" class='img' alt='JSON Responce'></p>
    
    <p>За повече информация, посетете: <a href='https://github.com/vuejs/petite-vue' target='_blank' class='lnk'>Petite Vue.js</a></p>
    
    <hr>
    <img src='../img/image013.jpg' class='img no-print' alt='C# Turbo Course'>
    <hr>
    
    <p>&nbsp;</p>

  </div>  <!-- content -->
  
  <canvas id='canvas' class='no-print'></canvas>
 
  <div id='chevron'>
    <div id='chev-inner' class='no-print'>
      <a data-scroll title='To Top' class='bounce' href='#top'> <span class='fa fa-chevron-up'></span> </a>
    </div>
  </div>
  
  <script src='../js/gumshoe.js'></script>
  <script src='../js/smooth-scroll.js'></script>
  <script src='../js/menu.js'></script>
  <script src='../js/script.js'></script>
  <script src='../js/shader.js'></script>

  
</body>

</html>